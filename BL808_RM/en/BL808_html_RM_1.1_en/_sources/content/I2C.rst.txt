==========
I2C
==========

Overview
=====
Inter-Integrated Circuit (I2C) is a serial communication bus, which uses a multi-slave and multi-master architecture and is connected to low-speed peripherals.
Each device has a unique address identifier and can be used as a transmitter or receiver. The address of each device connected to the bus can be set by software through a unique address and the existing master or slave relation. The master can work as a master transmitter or a master receiver.
If two or more masters are initialized at the same time, data can be prevented from being damaged through conflict detection and arbitration during transmission.

BL808 has four I2C controller masters, whose slaveAddr, subAddr, and data to be transferred can be flexibly configured, to facilitate communication with slaves. With the FIFO of 2-word depth and interrupt function, it can be used with DMA to improve efficiency and supports flexible adjustment of clock frequency.

Features
=========
- Master mode

- Multi-master mode and arbitration function

- Flexible adjustment of clock frequency

- Supports 10-bit address mode

- Supports DMA transfer mode

Functional Description
==========

.. table:: I2C pin list
    :widths: 30, 30, 40
    :width: 80%
    :align: center

    +----------+--------------+---------------------------+
    |   Name   |   Type       |    Description            |
    +==========+==============+===========================+
    | I2Cx_SCL | Input/output | I2C serial clock signal   |
    +----------+--------------+---------------------------+
    | I2Cx_SDA | Input/output | I2C serial data signal    |
    +----------+--------------+---------------------------+

Start and stop conditions
-----------------
All transmissions start with a START condition and end with a STOP condition.
The START and STOP conditions are generally generated by the master. The bus is considered to be busy after the START condition and to be idle for a certain period of time after the STOP condition.

START condition: SDA produces a high-to-low level transition when SCL is high;

STOP condition: SDA produces a low-to-high level transition when SCL is high.

Waveform diagram:

.. figure:: ../../picture/I2CStopStart.svg
   :align: center

   Start and stop conditions of I2C

Data Transfer Format
----------------

7-bit address mode:

The first 8 bits transferred are addressing bytes, including a 7-bit slave address and a 1-bit direction bit. Sending or receiving data by the master is controlled by the 8th bit in the first byte sent by the master. If it is 0, it means that the data is sent by the master, while "1" indicates that data is received by the master, followed by the slave sending out an acknowledgement (ACK) bit. Upon data transfer completed, the master sends out a STOP signal, with waveform shown below:

.. figure:: ../../picture/I2CMasterTxRx.svg
   :align: center

   I2C data transfer format

**Master Transmit and Slave Receive Timing**

.. figure:: ../../picture/I2CMasterTxSlaveRx.svg
   :align: center

   Timing of master transmitter and slave receiver

**Master Receive and Slave Transmit Timing**

.. figure:: ../../picture/I2CMasterRxSlaveTx.svg
   :align: center

   Timing of master receiver and slave transmitter

10-bit address mode: The cr_i2c_10b_addr_en in the register i2c_config must be set to 1 before use.

The 10-bit slave address consists of the two bytes after the START condition (S) or the repeated START condition (Sr). The first 7 bits of the first byte are 1111 0XX, where XX are the first two bits of MSB of the 10-bit address. The 8th bit of the first byte is the read/write bit that determines the transfer direction.
Although there are 8 possible combinations of 1111 XXX, only the four types of 1111 0XX can be used for 10-bit addressing, and the remaining four types of 1111 1XX are used for future I2C expansion.

The aforementioned read-write formats for 7-bit addressing all suit 10-bit addressing, as follows:

1. A master-transmitter sends data to a slave-receiver with a 10-bit slave address

.. figure:: ../../picture/I2CMasterToSlave10BitAddress.svg
   :align: center

The figure shows that the transfer direction is unchanged. When receiving the 10-bit address following the START condition, the slave compares the first byte (1111 0XX) of the slave address with its own address, and checks whether the eighth bit (read/write bit) is 0. It is possible that multiple devices all match and generate an acknowledgement (A1). Next, all the slaves start to match their own addresses with the 8 bits of the second byte (XXXX XXXX). At this time, only one slave matches and generates an acknowledgement (A2). The slave that is addressed by the master will remain in the addressed state until it receives a STOP condition or a repeated START condition, followed by a different slave address.

2. A master-receiver receives data from a slave-transmitter (10-bit slave address)

.. figure:: ../../picture/I2CSlaveToMaster10BitAddress.svg
   :align: center

The transfer direction will change after the second read/write bit. Before the second acknowledgement A2, the process is the same as that of the master-transmitter addressing the slave-receiver. After the repeated START condition (Sr), the matched slave will remain in the addressed state. This slave will check whether the first 7 bits of the first byte after Sr are correct, and then test whether the 8th bit is 1 (read). If this also matches, the slave considers that it is addressed as a transmitter and generates an acknowledgement (A3). The slave-transmitter will remain in the addressed state until it receives the STOP condition (P) or the repeated START condition (Sr) followed by a different slave address. Then, under Sr, all the slaves will compare their addresses with 11110XX and test the eighth bit (read/write bit). However, they will not be addressed, because for 10-bit devices, the read/write bit is 1, or for 7-bit devices, the slave addresses of 1111 0XX do not match.

Arbitration
------------
When there are multiple masters on I2C bus, it may happen that multiple masters start data transfer at the same time. At this time, the arbitration mechanism will decide which master has the right to transfer data, while other masters have to give up the control of the bus and wait until the bus is idle before transferring data again.

During data transfer, all masters must check whether the SDA is consistent with the data they want to send when SCL stays high. When the SDA level is different from the expected one, it means that other masters are transferring data at the same time. The masters with different SDA levels will lose the arbitration and other masters will complete the data transfer.

The waveform of two masters transferring data and initiating the arbitration mechanism at the same time is as follows:

.. figure:: ../../picture/I2CTxRxTogether.svg
   :align: center

   Waveform of simultaneous data transfer


I2C Clock Setting
==================

I2C clock can be derived from bclk (bus clock) and xclk, and frequency division can be done on this basis.
The register i2c_prd_data can divide the clock of the data segment. The I2C module divides data transfer into 4 stages. Each stage is controlled by a single byte in the register, and the number of samples of each stage can be set. The 4 numbers jointly determine the division factor of i2c clock.

For example, bclk is 32M now, and the default value of the register i2c_prd_data is 0x0f0f0f0f without configuration, so I2C's clock frequency is 32M/((15 + 1) * 4) = 500K.
Similarly, registers i2c_prd_start and i2c_prd_stop will divide the clock of the start and stop bits, respectively.

I2C Configuration Flow
========================

Configuration Items
------------------

- Read/write flag bit
- Slave address
- Slave register address
- Slave register address length
- Data (TX: configure the sent data; RX: store the received data)
- Data length
- Enable signal

Read/Write Flag Bit
-------------------------

I2C supports TX and RX working statuses. The cr_i2c_pkt_dir in the register i2c_config represents the TX/RX status, "0" for TX status and "1" for RX status.

Slave Address
-----------

Each slave connected to I2C will have a unique device address, which is usually 7 bits long. This address will be written into the cr_i2c_slv_addr in the register i2c_config. I2C will automatically shift to the left by 1 bit before sending the address, and the TX/RX direction bit will be added to the LSB.

Slave Register Address
-----------------

The slave register address represents the register address where I2C needs to read and write a slave register. The slave register address is written to the register i2c_sub_addr, and the cr_i2c_sub_addr_en in the register i2c_config must be set to 1.
If cr_i2c_sub_addr_en in the register i2c_config is set to 0, the I2C master will skip the slave register address field when sending.

Slave Register Address Length
----------------------

The slave register address length is subtracted by 1 and then written to cr_i2c_sub_addr_bc in the register i2c_config.

Data
--------

It refers to the data that needs to be sent to or received from the slave.
When sending data, I2C must write the data (in word) into the register i2c_fifo_wdata.
When receiving data, I2C must read out the data (in word) from the register i2c_fifo_rdata.

Data Length
---------

The data length is subtracted by 1 and then written to cr_i2c_pkt_len in the register i2c_config.

Enable Signal
---------

After the above items are configured, when cr_i2c_m\_en in the enable signal register i2c_config is set to 1, the I2C sending process will be started automatically.

When the read/write flag bit is configured as 0, I2C sends data and the master's transmission flow is as follows:

1. Start bit

2. (The slave address shifts to the left by 1 bit + 0) + ACK

3. Slave register address + ACK

4. 1-byte data + ACK

5. 1-byte data + ACK

6. Stop bit

When the read/write flag bit is configured as 1, I2C receives data and the master's transmission flow is as follows:

1. Start bit

2. (The slave address shifts to the left by 1 bit + 0) + ACK

3. Slave register address + ACK

4. Start bit

5. (The slave address shifts to the left by 1 bit + 1) + ACK

6. 1-byte data + ACK

7. 1-byte data + ACK

8. Stop bit

FIFO Management
============

I2C FIFO has a 2-word depth, and I2C includes RX FIFO and TX FIFO.
The rx_fifo_cnt in the register i2c_fifo_config_1 represents how much data (in word) in RX FIFO needs to be read.
The tx_fifo_cnt in the register i2c_fifo_config_1 represents how much free space (in word) in TX FIFO for writing.

I2C FIFO status:

- RX FIFO underflow: When the data in RX FIFO is completely read out or empty, if I2C continues to read data from RX FIFO, the rx_fifo_underflow in the register i2c_fifo_config_0 will be set to 1;

- RX FIFO overflow: When I2C receives data until the two words of RX FIFO are filled, without reading RX FIFO, if I2C receives data again, the rx_fifo_overflow in the register i2c_fifo_config_0 will be set to 1;

- TX FIFO underflow: When the data size filled into TX FIFO does not meet the configured I2C data length: cr_i2c_pkt_len in i2c_config, and no new data is filled into TX FIFO, the tx_fifo_underflow in the register i2c_fifo_config_0 will be set to 1;

- TX FIFO overflow: After the two words of TX FIFO are filled, before the data in TX FIFO is sent out, if data is filled into TX FIFO again, the tx_fifo_overflow in the register i2c_fifo_config_0 will be set to 1.

Use with DMA
============

I2C can send and receive data through DMA. Setting i2c_dma_tx_en in the register i2c_fifo_config_0 to 1 will enable the DMA TX mode. After the channel for I2C is allocated, DMA will transfer data from memory to the i2c_fifo_wdata register.
Setting i2c_dma_rx_en in the register i2c_fifo_config_0 to 1 will enable the DMA RX mode. After the channel for I2C is allocated, DMA will transfer the data in the register i2c_fifo_rdata to memory.
When I2C is used with DMA, DMA will automatically transfer data, so it is unnecessary for CPU to write data into I2C TX FIFO or read data from I2C RX FIFO.

DMA Sending Flow
-------------

1. Set read/write flag bit to 0

2. Set slave address

3. Set slave register address

4. Set slave register address length

5. Data Length

6. Set enable signal register to 1

7. Configure DMA transfer size

8. Configure the transfer width of DMA source address

9. Configure the transfer width of DMA destination address (when I2C is used with DMA, the transfer width of destination address must be set to 32 bits, which is word-aligned)

10. Configure the DMA source address as the memory address for storing sent data

11. Configure the DMA destination address to I2C TX FIFO address, i2c_fifo_wdata

12. Enable DMA

DMA Receiving Flow
----------------

1. Set read/write flag bit to 1

2. Set slave address

3. Set slave register address

4. Set slave register address length

5. Data Length

6. Set enable signal register to 1

7. Configure DMA transfer size

8. Configure the transfer width of DMA source address (when I2C is used with DMA, the transfer width of source address must be set to 32 bits, which is word-aligned)

9. Configure the transfer width of DMA destination address

10. Configure the DMA source address to I2C RX FIFO address, i2c_fifo_rdata

11. Configure the DMA destination address as the memory address for storing received data

12. Enable DMA

Interrupt
============

I2C includes the following interrupts:

- I2C_TRANS_END_INT: I2C end of transfer interrupt

- I2C_TX_FIFO_READY_INT: The interrupt is triggered when I2C TX FIFO has free space for padding

- I2C_RX_FIFO_READY_INT: The interrupt is triggered when I2C RX FIFO receives data

- I2C_NACK_RECV_INT: The interrupt is triggered when I2C detects the NACK state

- I2C_ARB_LOST_INT: I2C arbitration lost interrupt

- I2C_FIFO_ERR_INT: I2C FIFO ERROR interrupt

.. only:: html

   .. include:: dma2d_register.rst

.. raw:: latex

   \input{../../en/content/i2c}