===========
SEC ENG
===========

Overview
=====
AES 
-------------
Advanced Encryption Standard (AES) is the most common type of symmetric encryption algorithm. Also known as Rijndael encryption algorithm in cryptography, it is a block encryption standard adopted by the U.S. federal government.

MD5
-------------
Message Digest Algorithm 5 (MD5), a widely used cryptographic hash function, can generate a 128-bit (16-byte) hash value, to ensure the integrity and consistency of information transmission.

SHA
-------------
SHA256 is a variant of Secure Hash Algorithm 2 (SHA2). SHA2, the successor of SHA1, is a cryptographic hash function algorithm standard designed by the United States National Security Agency.
SHA2 has six different variants: SHA224, SHA256, SHA384, SHA512, SHA512/224, and SHA512/256.SHA-512/224 means that the result takes the first 224 bits of SHA-512, and SHA-512/256 means that the result takes the first 256 bits of SHA-512.

CRC
-------------
Cyclic Redundancy Check (CRC) is a channel coding technique that generates short fixed-digit check codes based on data including network packets or computer files. It is mainly used to detect or check possible errors after data transfer or storage. It detects errors based on the principle of division and remainder.

GMAC
-------------
GMAC is to use Galois Field (GF, finite field) multiplication to calculate the MAC value of a message.

Features
=========
- Encryption and decryption of aes128, aes192, and aes256

- Crc16, crc32, md5, sha256, and sha512

- Trng

- Gmac

Principle
===========
AES means that the same key is used for encryption and decryption, with encryption process as follows:

.. figure:: ../../picture/SecEngAes.svg
   :align: center

   AES Encryption Process

The following briefs the functions and significance of each part:

- Plaintext (P): unencrypted data.

- Key (K): The key used to encrypt plaintext. In symmetric encryption algorithm, encryption and decryption share one key. The key is generated by negotiation between the receiver and the sender, but it cannot be directly transmitted over network. Otherwise it will leak the key. Usually, the key is encrypted by an asymmetric encryption algorithm, and then transmitted to the other side over network, or the key is discussed face to face. The key must not be leaked. Otherwise the attacker will restore the ciphertext and steal confidential data.

- AES encryption function: Let this function be E, then C = E(K, P), where P, K and C denote plaintext, key, and ciphertext, respectively. That is, if plaintext (P) and key (K) are input as the parameters of function, this function will output ciphertext (C).

- Ciphertext (C): data processed by encryption function.

- AES decryption function: Let this function be D, then P = D(K, C), where C, K, and P denote ciphertext, key, and plaintext, respectively. That is, if ciphertext (C) and key (K) are input as the parameters of function, this function will output plaintext (P).

Implementation of MD5
-------------
MD5 can be regarded as a block-based algorithm, as it requires that the length of data processed each time is 512 bits. However, the length of plaintext to be actually processed is not always an integer multiple of 512, so data padding is required. Assuming that the length of the original plaintext message is K, the padding of MD5 is further divided into 2 steps:

1. Append padding bits: 100\... are padded after the K bits of the original plaintext message until 512-64 = 448 bits. The padding rule is that only the first bit is 1, followed by all zeros.

2. Append length: The length of the original message is filled after the result of the first step, and the available storage length is 64 bits. The whole padding process is as follows:

.. figure:: ../../picture/SecEngMd5Padding.svg
   :align: center

   MD5 Padding

Data to be used:

 - Four constants: A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476;
 - Four functions: F(X,Y,Z)=(X & Y) | ((~X) & Z); G(X,Y,Z)=(X & Z) | (Y & (~Z));  H(X,Y,Z)=X ^ Y ^ Z; I(X,Y,Z)=Y ^ (X | (~Z));

The message is divided into 512-bit groups for processing. Each group undergoes 4 rounds of transformation. The above 4 constants are used as the initial variables for calculation, to re-output 4 variables, based on which the next group is calculated. For the last group, the 4 variables are the final result, namely MD5 value.

Implementation of SHA256
--------------------------

It is implemented in a way similar to that of MD5. Its rule of data padding is the same as that of MD5. SHA256 uses 8 initial hash values and 64 hash constants.

The 8 initial hash values are as follows:

 - h0 = 0x6a09e667
 - h1 = 0xbb67ae85
 - h2 = 0x3c6ef372
 - h3 = 0xa54ff53a
 - h4 = 0x510e527f
 - h5 = 0x9b05688c
 - h6 = 0x1f83d9ab
 - h7 = 0x5be0cd19

These initial values are obtained by taking the first 32 bits from the decimal part of the square root of the first 8 prime numbers (2, 3, 5, 7, 11, 13, 17, and 19) in natural numbers.

The 64 constants are as follows:

- 428a2f98 71374491 b5c0fbcf e9b5dba5
- 3956c25b 59f111f1 923f82a4 ab1c5ed5
- d807aa98 12835b01 243185be 550c7dc3
- 72be5d74 80deb1fe 9bdc06a7 c19bf174
- e49b69c1 efbe4786 0fc19dc6 240ca1cc
- 2de92c6f 4a7484aa 5cb0a9dc 76f988da
- 983e5152 a831c66d b00327c8 bf597fc7
- c6e00bf3 d5a79147 06ca6351 14292967
- 27b70a85 2e1b2138 4d2c6dfc 53380d13
- 650a7354 766a0abb 81c2c92e 92722c85
- a2bfe8a1 a81a664b c24b8b70 c76c51a3
- d192e819 d6990624 f40e3585 106aa070
- 19a4c116 1e376c08 2748774c 34b0bcb5
- 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
- 748f82ee 78a5636f 84c87814 8cc70208
- 90befffa a4506ceb bef9a3f7 c67178f2

Similarly, these constants are obtained by taking the first 32 bits from the decimal part of the cube root of the first 64 prime numbers (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97...) in natural numbers.

SHA256 hash function:

 - Ch(x,y,z)=(x∧y)⊕(¬x∧z)
 - Ma(x,y,z)=(x∧y)⊕(x∧z)⊕(y∧z)
 - Σ0(x)=S \ :sup:`2` (x)⊕S \ :sup:`13` (x)⊕S \ :sup:`22` (x)
 - Σ1(x)=S \ :sup:`6` (x)⊕S \ :sup:`11` (x)⊕S \ :sup:`25` (x)
 - σ0(x)=S \ :sup:`7` (x)⊕S \ :sup:`18` (x)⊕R \ :sup:`3` (x)
 - σ1(x)=S \ :sup:`17` (x)⊕S \ :sup:`19` (x)⊕R \ :sup:`10` (x)

Where:

 - ∧: bitwise "AND"
 - ¬: bitwise "Padding"
 - ⊕: bitwise "Exclusive OR"
 - S \ :sup:`n` : Circularly shift right by n bits
 - R \ :sup:`n` : Shift right by n bits

Principle of GMAC
-------------
Authentication is actually a redundant message generated against the message itself, that is, the message authentication code (MAC). MAC is a technique for authenticating the integrity of a message. In cryptography, MAC refers to a verification mechanism used by both communication entities and a tool to ensure the integrity of message data.
MAC is a hash function with a key. But why does it need a key? The reason is that the message can be tampered with during transmission, so can the hash value. Therefore, to ensure a valid hash value, the hash value is protected by encryption, so that the receiver can judge the integrity of the whole message through the hash value upon reception, thus completing information transfer.

The MAC process is shown as follows:

.. figure:: ../../picture/SecEngMac.svg
   :align: center

   MAC Flow Chart

1. The sender and the receiver share the key K in advance (keep KEY1 and KEY2 values in the above figure consistent).

2. The sender calculates the MAC value based on the message (KEY1 is used to calculate the MAC1 for the original message).

3. The sender sends the original message and MAC1 to the receiver.

4. The receiver calculates MAC2 using KEY2 based on the received original message .

5. The receiver compares the calculated MAC2 with the MAC1 received from the sender.

6. If the MAC is consistent, the receiver can judge that the message is indeed from the sender (authentication succeeded) and has not been tampered with or there is a transmission error. If not, the message is not from the sender (authentication failed).

Note: It is recommended that the sender and the receiver store the KEY in the hardware security module, and the MAC value also shall be calculated in that module, to ensure the security of KEY, for example, in the encrypted chip.

GMAC is to use Galois Field (GF, finite field) multiplication to calculate the MAC value of a message.

Functional Description
===========

AES Accelerator
-------------
1. AES accelerator supports AES128/192/256 encryption and decryption.

- Configure se_aes_0\_mode and se_aes_0\_dec_en in the register se_aes_0\_ctrlL, as shown below:

.. figure:: ../../picture/SecEngAesMode.svg
   :align: center

   AES Operation Modes

Configure se_aes_0\_block_mode in the register se_aes_0\_ctrlL to select among different encryption modes including ECB, CTR, CBC, and XTS.

2. Key, plaintext, ciphertext, and initialization vector

- The register se_aes_0\_msa stores the address of plaintext or ciphertext.

- The register se_aes_0\_msa stores the address of ciphertext or plaintext.

- The register se_aes_0\_iv_0\~se_aes_0\_iv_3 stores IV.

- The register se_aes_0\_key_0\~se_aes_0\_key_7 stores the key.

3. Software and hardware encryption process

- Configure the register se_aes_0\_endian, including se_aes_0\_dout_endian, se_aes_0\_din_endian, se_aes_0\_key_endian, se_aes_0\_iv_endian, and se_aes_0\_twk_endian

   Note: 0: littleendian 1: bigendian

- Configure se_aes_0\_block_mode in the register se_aes_0\_ctrlL

- Configure se_aes_0\_mode in the register se_aes_0\_ctrlL

- Configure se_aes_0\_dec_en in the register se_aes_0\_ctrlL

- Configure se_aes_0\_dec_key_sel 0:new key 1:same key as last one in the register se_aes_0\_ctrlL

- Configure se_aes_0\_iv_sel 0:new iv 1:same iv as last one in the register se_aes_0\_ctrlL

- Configure se_aes_0\_en enable aes in the register se_aes_0\_ctrlL

- Configure the register se_aes_0\_iv_0\~se_aes_0\_iv_3 set IV.

   Sequence of filling: MSB: se_aes_0\_iv_0\~se_aes_0\_iv_3; LSB: se_aes_0\_iv_3\~se_aes_0\_iv_0

- Configure the register se_aes_0\_key_0\~se_aes_0\_key_7 set key.

   Sequence of filling: MSB: se_aes_0\_key_0\~se_aes_0\_key_7; LSB: se_aes_0\_key_7\~se_aes_0\_key_0.

   Bits for filling: first 4 bits for AES128; first 6 bits for AES196, and first 8 bits for AES256.

- Configure the register se_aes_0\_msa set msa addr

- Configure the register se_aes_0\_msa set mda addr

- Configure se_aes_0\_msg_len set msg len in the register se_aes_0\_ctrlL

- Configure se_aes_0\_trig_1t Trigger AES Engine in the register se_aes_0\_ctrlL

- The output result is stored in the address corresponding to the register se_aes_0\_mda

SHA Accelerator
-------------
1. SHA accelerator supports 7 standard operations:

 - SHA-1、SHA-224、SHA-256、SHA-512、SHA-384、SHA-512/224、SHA-512/256，同时还支持MD5、CRC16、CRC32。

The se_sha_0\_mode in the register se_sha_0\_ctrl:   0:SHA-256 1:SHA-224 2:SHA-1 3:SHA-1 4:SHA-512 5:SHA-384 6:SHA-512/224 7:SHA-512/256

The se_sha_0\_mode_ext in the register se_sha_0\_ctrl: hash mode extention; 0:SHA 1:MD5 2:CRC-16 3:CRC-32

Configure se_sha_0\_mode in the register se_sha_0\_ctrl to select among different SHA operations, and configure se_sha_0\_mode_ext in the register se_sha_0\_ctrl to select among MD5, CRC16, and CRC32

- The se_sha_0\_mode is valid when se_sha_0\_mode_ext is 0.

- The se_sha_0\_mode is invalid when se_sha_0\_mode_ext is not 0.

2. Plaintext and ciphertext

- The register se_sha_0\_msa stores the plaintext address.

- The register se_sha_0\_hash_l\_0\~se_sha_0\_hash_l\_7 stores the ciphertext.

Sequence: MSB: se_sha_0\_hash_l\_0\~se_sha_0\_hash_l\_7; LSB: se_sha_0\_hash_l\_7\~se_sha_0\_hash_l\_0

3. Operation flow

- Configure se_sha_0\_mode set SHA operation type in the register se_sha_0\_ctrl

- Configure se_sha_0\_en enable sha in the register se_sha_0\_ctrl

- Configure se_sha_0\_hash_sel 0:new hash 1:accumulate last hash in the register se_sha_0\_ctrl

- Configure the register se_sha_0\_msa set mda addr

- Configure se_sha_0\_msg_len set msg len in the register se_sha_0\_ctrl

- Configure se_sha_0\_trig_1t Trigger SHA Engine in the register se_sha_0\_ctrl

- The output result is stored in se_sha_0\_hash_l\_0\~se_sha_0\_hash_l\_7
   MSB:se_sha_0\_hash_l\_0\~se_sha_0\_hash_l\_7
   LSB:se_sha_0\_hash_l\_7\~se_sha_0\_hash_l\_0

Random Number Generator (RNG)
-------------
1. The random numbers generated by the built-in true RNG can be used as the basis for encryption and other operations.

- True random numbers: They are generated through physical phenomena, such as coin tossup, dicing, wheel rotation, noise from using electronic components, and nuclear fission. Such RNGs are called physical RNGs, and their weaknesses are high technical requirements.

- Pseudo-random numbers: Truly random numbers (or random events) are randomly generated in a generation process according to the distribution probability shown in the experimental process, and the result is unpredictable and invisible. The random function in the computer is simulated according to a specified algorithm, and its result is deterministic and visible. We can think that the probability of this foreseeable result is 100%. Hence the "random number" generated by computer random function is not truly random, but pseudo-random.

2. Output

- The register SE_TRNG_0\_DOUT_0\~SE_TRNG_0\_DOUT_7 stores the output random number.

3. Usage process

- Configure se_trng_0\_en enable trng in the register se_trng_0\_ctrl_0

- Configure se_trng_0\_trig_1t trigger trng engine in the register se_trng_0\_ctrl_0

- The output result is stored in se_trng_0\_dout_0\~se_trng_0\_dout_7

GMAC(link Mode)
--------------------------
1. Definition of GMAC_link_Table Structure

 - Word0:

     + [9]:se_gmac_0_int_clr_1t
     + [10]:se_gmac_0_int_set_1t
     + [31:16]:se_gmac_0_msg_len

 - Word1:se_gmac_0_msa
 - Word2、Word3、Word4、Word5：se_gmac_0_h
 - Word6、Word7、Word8、Word9：se_gmac_0_tag

2. Usage process

- Configure se_gmac_0\_x_endian, se_gmac_0\_h_endian, and se_gmac_0\_t_endian 0:littleendian 1:bigendian in the register se_gmac_0\_ctrl_0

- Write the start address of the GMAC_link_Table structure into the register se_gmac_0\_lca

- Assign the original message address to se_gmac_0\_msa in Word1 in GMAC_link_Table structure

- Assign the original message length to se_gmac_0\_msg_len in Word0 in GMAC_link_Table structure, where the 128-bit message length corresponds to 1 in se_gmac_0\_msg_len

- Configure se_gmac_0\_trig_1t trigger gmac engine in the register se_gmac_0\_ctrl_0

- The output result is stored in Word6–Word9 in the GMAC_link_Table structure

.. only:: html

   .. include:: sec_register.rst

.. raw:: latex

   \input{../../en/content/sec}