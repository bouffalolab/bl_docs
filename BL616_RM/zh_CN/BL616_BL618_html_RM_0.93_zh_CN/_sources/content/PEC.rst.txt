====
PEC
====

简介
=====
PEC(Peripheral Expand Controller)是一种多功能的硬件接口，可以支持很多标准IO如8080/6800、I2C、3线I2S、SDIO、SPI/DSPI/QSPI、UART、DPI、VGA（配合电阻网络）等。PEC也像一般处理器那样可以编程，和一般处理器不一样的是PEC是为IO高度定制的，侧重于精确且严格的时序，并且是和固定功能的硬件紧密集成。

主要特征
=========

- 4个可独立运行的状态机

- 32条指令储存空间

- 2组可自由配置的中断

- 16位指令宽度，9种类型指令

- 每条指令都可以设置延时并控制IO

每个状态机的特征如下：

- 2个32bits移位寄存器，可以任意方向移位，任意移动位数

- 2个32bits的暂存寄存器

- 每个方向都有8*32bits的FIFO

- 小数时钟分频（16位整数，8位小数）

- 灵活的GPIO映射

- DMA接口

- IRQ标志的置位、清除及获取

功能介绍
=========
编程模型
----------
控制流
^^^^^^^
每个状态机的取指、解码和执行都在一个时钟周期内完成，每条指令精确地需要一个周期，除非预期等待（比如WAIT指令）。指令也可以在执行完成后等待最多31个周期再执行下一条指令，这样可以避免增加延时的代码。程序计数器PC指向当前正在执行的指令所在的储存空间的位置，一般来说，PC每个周期会自增1，并且在指令存储空间的末尾绕回。跳转指令会精确地指定下一条指令执行的位置。

寄存器
^^^^^^^
每个状态机都有一些内部寄存器，这些寄存器可用于储存输入输出的数据，或者存储例如用于循环次数的临时变量等。

**输出移位寄存器（OSR）**

.. figure:: ../../picture/PECOsr.svg
   :align: center

OSR用来保存并移位TX FIFO和引脚（也可以是其他目的地比如暂存寄存器）之间的数据。

- PULL指令可以将一个32位数据从TX FIFO拉取到OSR。
- OUT指令可以一次将1~32位数据从OSR移位到其他目的地。
- OSR中的数据被移出后用0补齐。
- 一旦使能了自动拉取，并且当移位的总数达到设定的阈值时，在OUT指令后状态机会自动用FIFO中的数据重新填充OSR。
- 处理器通过配置寄存器可以设定移位方向为向左或者向右。

**输入移位寄存器（ISR）**

.. figure:: ../../picture/PECIsr.svg
   :align: center

- IN指令可以一次将1~32位数据移位到ISR。
- PUSH指令可以将ISR中的数据写入到RX FIFO中。
- ISR中的数据被推送后即被清零。
- 如果使能了自动推送，当移位的总数达到设定的阈值时，在IN指令后状态机会自动推送ISR中的数据。
- 处理器通过配置寄存器可以设定移位方向。

**移位计数值**

状态机会将OUT指令移出OSR的位数和IN指令移入ISR的位数记录下来，这些信息由两个硬件计数器跟踪记录，计数值范围为0~32（移位寄存器的宽度）。状态机可以配置为在计数值达到阈值时做一些特定的如下动作：

- 一旦移出位数达到阈值可以重新填充OSR。
- 一旦移入位数达到阈值，ISR可以被清空。
- PUSH和PULL指令也可以配置为各自独立地依赖输入和输出的移位长度。

PEC复位后或者使用cr_sm_reset进行复位后，ISR移位计数值会被清零即还没有移出，OSR移位计数值会被初始化为32即没有未移出的数据。其他一些指令也会影响移位计数值，包括如下：

- PULL指令会将输出移位计数值清零
- PUSH指令会将输入移位计数值清零
- MOV指令使用OSR作为目的地时会将输出移位计数器清零
- MOV指令使用ISR作为目的地时会将输入移位计数器清零
- OUT指令将ISR作为目的地时会将输入移位计数器的值设定为OUT指令中指定的值

**暂存寄存器**

每个状态机都有两个内部暂存寄存器，被称为X和Y。这两个寄存器被用于以下场景：

- IN/OUT/SET/MOV指令的源和目的地
- 跳转的判断条件

**先进先出缓冲区**

每一个状态机都有两个8字深度的先进先出缓冲区，一个用于从系统到状态机即发送，一个用于从状态机到系统即接收。发送缓冲区由处理器或DMA等主机控制器写入数据，接收缓冲区由状态机写入数据。缓冲区使状态机和系统总线的时序分离，允许状态机在没有处理器干预的情况下运行更长的时间。

缓冲区还可以生成数据请求信号，允许系统DMA控制器根据RX FIFO和TX FIFO中的数据目前占用状态来调整其读写速度，这允许处理器收发上千字节的数据而不需要处理器的干预。

阻塞
^^^^^^^

状态机可能因为以下一些原因而阻塞：

- WAIT指令所需条件尚未满足
- TX FIFO为空时PULL指令会阻塞，或者RX FIFO为满时PUSH指令会阻塞
- IRQ指令将中断标志置位并等待其清零
- 当自动拉取使能时，OSR移位计数值已经达到阈值但TX FIFO为空时，OUT指令会阻塞
- 当自动推入使能时，ISR移位计数值已经达到阈值但RX FIFO为满时，IN指令会阻塞

在以上所述情况下，程序计数器不会增加并且状态机在下一个周期仍然会执行该条指令。如果指令指明了延时周期则只有当阻塞取消后延时才会开始。

引脚映射
^^^^^^^^^^^

PEC既可以控制多达32个GPIO口的输出电平高低和方向，也可以获取它们的输入电平，在每一个系统时钟周期，每个状态机可以操作如下属性或什么都不操作：

- 通过OUT或SET指令改变一些GPIO的电平或方向，或者通过IN指令获取一些GPIO的状态
- 通过侧置功能操作一些GPIO的电平或方向

以上操作都是控制连续的GPIO，这一连续GPIO的起始引脚和GPIO数量在每个状态机的PINCTRL寄存器中可以配置。OUT、SET、IN以及侧置功能都有各自独立的引脚映射关系，并且他们之间允许重叠。

对于每个单独的GPIO输出（包括电平和方向，他们是分开的），在一个周期内最多有4个状态机的同时写入操作，此时状态机序号最高的写入生效。如果一个状态机的SET/OUT指令和侧置功能同时操作同一个GPIO，则侧置功能生效。如果没有状态机对GPIO进行操作，则GPIO的值维持前一个周期的状态不会改变。

一般来说每个状态机的输出是映射到独立的GPIO上，用来实现一些外设接口。

IRQ标志
^^^^^^^^^

IRQ标志是可以被状态机或系统置位或清除的标志位，一共有8个都可以被状态机读写的IRQ标志，其中低4位还可以通过IRQ0_INTE和IRQ1_INTE来控制是否产生PEC的中断请求。IRQ标志主要有以下两大用处：

- 让状态机和系统中断相关联，并且状态机可以等待中断应答
- 让两个状态机之间同步执行

状态机之间可以通过IRQ和WAIT指令进行交互。

状态机间相互作用
^^^^^^^^^^^^^^^^^^

指令储存空间被实现为1写4读的寄存器文件，因此4个状态机可以同时无阻塞地读取指令。对于多个状态机共用指令存储空间有以下3种使用方式：

- 多个状态机使用相同的程序代码
- 多个状态机使用不同的程序代码
- 不同的状态机运行一个接口的不同部分，比如UART的发送和接收功能分离，或者DPI显示接口的时钟同步信号与像素数据信号分离

状态机之间不能传输数据，但是它们之间可以通过IRQ标志位进行同步。一共有8个标志位（低4位可以被用来触发系统中断），每个状态机都可以通过IRQ指令置位或清除标志位，也可以使用WAIT指令等待标志位，这样的机制允许状态机之间实现精确的周期同步。

指令集
--------
Summary
^^^^^^^^^

PEC指令长度为16位，编码格式如下表所示：

.. table:: PEC指令编码表 has_header

    +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
    |Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
    +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
    |JMP | 0  | 0  | 0  |     Delay/side-set     |  Condition   |        Address         |
    +----+----+----+----+------------------------+----+---------+------------------------+
    |WAIT| 0  | 0  | 1  |     Delay/side-set     |Pol | Source  |         Index          |
    +----+----+----+----+------------------------+----+---------+------------------------+
    | IN | 0  | 1  | 0  |     Delay/side-set     |    Source    |       Bit count        |
    +----+----+----+----+------------------------+--------------+------------------------+
    |OUT | 0  | 1  | 1  |     Delay/side-set     | Destination  |       Bit count        |
    +----+----+----+----+------------------------+----+----+----+----+----+----+----+----+
    |PUSH| 1  | 0  | 0  |     Delay/side-set     | 0  |IfF |Blk | 0  | 0  | 0  | 0  | 0  |
    +----+----+----+----+------------------------+----+----+----+----+----+----+----+----+
    |PULL| 1  | 0  | 0  |     Delay/side-set     | 1  |IfE |Blk | 0  | 0  | 0  | 0  | 0  |
    +----+----+----+----+------------------------+----+----+----+----+----+----+----+----+
    |MOV | 1  | 0  | 1  |     Delay/side-set     | Destination  | Op |      Source       |
    +----+----+----+----+------------------------+----+----+----+----+----+----+----+----+
    |IRQ | 1  | 1  | 0  |     Delay/side-set     | 0  |Clr |Wait|         Index          |
    +----+----+----+----+------------------------+----+----+----+------------------------+
    |SET | 1  | 1  | 1  |     Delay/side-set     | Destination  |          Data          |
    +----+----+----+----+------------------------+--------------+------------------------+

PEC的每条指令的执行都只需要一个时钟周期。

Delay/side-set域在每条指令中都存在，它的确切用途由每个状态机的PINCTRL寄存器中的sideset_count配置，具体描述如下：

- 最多5位高位部分编码为侧置功能，侧置功能在一条指令执行的同时通过一个确定的值来控制一些GPIO
- 剩余的低位部分决定在下条指令执行前延时的周期数

JMP
^^^^^

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|JMP | 0  | 0  | 0  |     Delay/side-set     |  Condition   |        Address         |
+----+----+----+----+------------------------+----+---------+------------------------+

该指令的作用是当条件满足时，程序计数器将跳转到设定的地址处，如果条件没满足则不跳转。

需要注意的是不管条件是否成立，延时都会生效，延时从条件判断完并且程序计数器更新后开始。

判断条件（Condition）如下：

- 000：永远跳转（没有条件）
- 001：!X，暂存寄存器X为0
- 010：X--，暂存寄存器X非零，并且判断后该寄存器自减一
- 011：!Y，暂存寄存器Y为0
- 100：Y--，暂存寄存器Y非零，并且判断后该寄存器自减一
- 101：X!=Y，暂存寄存器X和Y不相等
- 110：PIN，跳转引脚
- 111：!OSRE，输出移位寄存器非空

地址（Address）：这是将要跳转的指令地址，在指令编码中，该地址是PEC指令储存器中的绝对地址。

跳转引脚（PIN）：该引脚由EXECTRL寄存器中的jmp_pin确定，如果该引脚为高电平则跳转。

输出移位寄存器非空（!OSRE）：将从上一次PULL后至现在移出的总位数和SHIFTCTL寄存器中的pull_thresh进行比较来进行判断OSR是否为空，这个阈值也是自动拉取的阈值。

WAIT
^^^^^

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|WAIT| 0  | 0  | 1  |     Delay/side-set     |Pol | Source  |         Index          |
+----+----+----+----+------------------------+----+---------+------------------------+

在条件满足前将一直阻塞。

和所有的阻塞指令一样，延时都是在指令完成后开始的，也就是说直到等待的条件满足后，延时才会开始。

极性（Pol）：

- 1：等待1。
- 0：等待0。

源（Source）：等待的对象，可以为以下描述的值：

- 00：GPIO：由 **Index** 指定的系统GPIO输入引脚，这是GPIO的绝对序号，和状态机的输入引脚映射没有关系。
- 01：PIN：由 **Index** 指定的输入引脚，这是由输入引脚映射到的GPIO序号加上 **Index** 得到的引脚决定。
- 10：IRQ：由 **Index** 指定的IRQ标志位。
- 11：保留

序号（Index）：决定等待的引脚序号。

等待IRQ标志的行为和等待其他源有点不一样，描述如下：

- 如果极性（Pol）为1，则一旦等待条件满足时，被选择的IRQ标志位会被清除。
- 这里标志序号和IRQ指令的序号的解码方式是一样的，如果标志序号的最高位为1，则状态机的ID号将会与标志序号相加再除以4得到的余数作为IRQ的序号。比如2号状态机的序号值写0x11，则其将等待IRQ的第3位，2号状态机的序号值写0x13，则其将等待IRQ的第1位。这样的机制允许多个状态机运行同一个代码时进行同步。

IN
^^^^

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
| IN | 0  | 1  | 0  |     Delay/side-set     |    Source    |       Bit count        |
+----+----+----+----+------------------------+--------------+------------------------+

将 **Source** 中的 **Bit count** 长度的位移位到ISR中，移位方向由每个状态机的SHIFTCTRL寄存器中的in_shiftdir配置，此外，输入移位计数值也会相应加上 **Bit count** ，饱和值为32。

源（Source）：

- 000：PINS
- 001：X（暂存寄存器X）
- 010：Y（暂存寄存器Y）
- 011：NULL（全0）
- 100：保留
- 101：保留
- 110：ISR
- 111：OSR

位数（Bit count）：移位到ISR的位数，范围为1~32，32用0表示。

如果使能了自动推送功能，则移位计数值达到推送阈值时，IN指令也会将数据从ISR推送到RX FIFO中，不管自动推送是否发生，IN指令的执行都只占用一个周期，如果RX FIFO已经满了，则状态机会阻塞。自动推送后，ISR中数据被清零并且输入移位计数值也清零。

IN指令总是将数据源中低 **Bit count** 位的数据作为有效数据，例如当寄存器SMx_PINCTRL中的cr_smx_in_base为5时，指令 **IN 3, PINS** 将会把PIN5~7的数据移位到ISR，ISR首先向左或向右移位以腾出输出数据的空间，然后输入数据会被拷贝到腾出的空间。需要注意的是输入数据的顺序和移位方向没有关系。

NULL也可以作为IN指令的输入源，比如对于UART接收来说总是先接收最低位，这就要求移位方向是向右移动。当使用IN指令从PIN脚获取8次数据后，这些数据将会在ISR的bit31~24，使用NULL作为数据源的IN指令向右移动24位，将使接收数据移动到bit7~0。当然也可以使用另一种方案，就是处理器或DMA从FIFO地址加3的位置获取FIFO中bit31~24位数据。


OUT
^^^^

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|OUT | 0  | 1  | 1  |     Delay/side-set     | Destination  |       Bit count        |
+----+----+----+----+------------------------+----+----+----+----+----+----+----+----+

OUT指令的作用是将 **Bit count** 位的数据从OSR输出到 **Destination** 定义的目的地，此外该指令的执行也会使输出移位计数器的值增加 **Bit count** ，最多增加到32饱和。

目的地（Destination）：

- 000：PINS
- 001：暂存寄存器X
- 010：暂存寄存器Y
- 011：NULL（放弃数据）
- 100：PINDIRS（引脚输入输出方向）
- 101：PC（程序计数器）
- 110：ISR（该操作会设置输入移位计数器的值为 **Bit count** ）
- 111：EXEC（将OSR移出的数据作为指令）

位数（Bit count）：将要移出OSR的位数，范围为1~32，32用0表示。

OUT指令的作用是将一个32bits数据写入到目的地，其中低 **Bit count** 位部分来自OSR，剩余部分都是0。如果SMx_SHIFTCTL寄存器中的cr_smx_out_shiftdir设置为右移则这个数据是OSR的低位部分，如果cr_smx_out_shiftdir设置为左移则这个数据是OSR的高位部分。

目的地为PINS或PINDIRS时，使用 **OUT** 的引脚映射关系。

如果使能了自动拉取，一旦SMx_SHIFTCTRL寄存器中的cr_smx_pull_thresh设置的阈值达到，则OSR中的数据会自动被TX FIFO填充，同时输出移位计数器也会被清零。在这样的情况下，如果TX FIFO为空，则OUT指令会阻塞，否则仍会在一个周期内完成。

以EXEC作为目的地的OUT指令允许将指令包含在FIFO的数据流中，OUT指令本身执行需要一个周期，来自OSR中的指令将会在下一个周期执行。在这种机制下，对可以执行的指令没有特别的限制，但是OUT指令自身的延时会被忽略，被执行的指令可以正常插入延时。

以PC作为目的地的OUT指令类似于一条无条件跳转指令，跳转目的地为从OSR移出的输出数据作为偏移在指令储存地址中的对应地址。

PUSH
^^^^^

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|PUSH| 1  | 0  | 0  |     Delay/side-set     | 0  |IfF |Blk | 0  | 0  | 0  | 0  | 0  |
+----+----+----+----+------------------------+----+----+----+----+----+----+----+----+

PUSH指令的作用是将ISR中的数据以32bits推送到RX FIFO中，然后将ISR清零。

- **IfF** （如果满，if full）：该位为1时，在总的输入移位计数值达到SMx_SHIFTCTRL寄存器中的cr_smx_push_thresh设定的阈值前，PUSH指令不生效，自动推送的机制也是这样的。

- **Blk** （阻塞，blocking）：该位为1时，如果RX FIFO已经满了，则会暂停执行。

PULL
^^^^^

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|PULL| 1  | 0  | 0  |     Delay/side-set     | 1  |IfE |Blk | 0  | 0  | 0  | 0  | 0  |
+----+----+----+----+------------------------+----+----+----+----+----+----+----+----+

PULL 指令的作用是将一个32位的数据从TX FIFO加载到OSR中。

- **IfE** （如果空， if empty）： 该位为1时，在总的输出移位计数值达到SMx_SHIFTCTRL寄存器中的cr_smx_pull_thresh设定的阈值前，PULL指令不生效，自动拉取的机制也是这样的。

- **Blk** （阻塞，blocking）：该位为1时，如果TX FIFO为空则暂停运行。该位为0时，如果TX FIFO为空则从暂存寄存器X取一个数据放到OSR中。

一些外设比如UART或SPI等，当没有可用数据时应该暂停，当有数据到来时再将其取出进行操作，其他一些外设比如I2S应该连续运行，并且在没有可用数据时用占位符或重复数据来填充也比暂停更合适，这样的应用场景下用 **Blk** 参数就可以实现。

当TX FIFO为空时，一条不带阻塞的PULL指令和 **MOV OSR,X** 效果是一样的，程序可以给暂存寄存器X一个合适的预装值或者在每条不带阻塞的PULL指令后执行 **MOV X,OSR** ，这样可以在新的有效数据到来之前一直使用FIFO中的最后的有效数据。

MOV
^^^^

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|MOV | 1  | 0  | 1  |     Delay/side-set     | Destination  | Op |      Source       |
+----+----+----+----+------------------------+----+----+----+----+----+----+----+----+

MOV指令的作用是将数据从 **Source** 复制到 **Destination** 。

**Destination** ：

- 000：PINS（和OUT指令使用相同的引脚映射）
- 001：暂存寄存器X
- 010：暂存寄存器Y
- 011：保留
- 100：EXEC（将数据作为指令执行）
- 101：PC（程序计数器）
- 110：ISR（输入移位计数器会被清零，也就是ISR为空）
- 111：OSR（输出移位计数器会被清零，也就是OSR满）

**Operation** ：

- 00：常规操作
- 01：按位取反
- 10：位反转
- 11：保留

**Source** ：

- 000：PINS（和IN指令使用相同的引脚映射）
- 001：暂存寄存器X
- 010：暂存寄存器Y
- 011：NULL（全0）
- 100：保留
- 101：FIFO状态
- 110：ISR
- 111：OSR

以PC为目的地的MOV指令会引起无条件跳转。以EXEC为目的地的MOV指令和目的地为EXEC的OUT指令作用是一样的，这会将寄存器中的数据作为一条指令执行，MOV指令本身的执行占用一个周期， **Source** 指定的指令会紧接着在下一个周期执行，在这样的情况下指令中指明的延时会被忽略，但是指令中 **Source** 指定的指令的延时是生效的。

FIFO状态作为源时，其数据只有两种，要么是全0要么是全1，这和各自状态机的FIFO状态有关，这可以由SMx_EXECCTRL寄存器中cr_smx_status_sel与cr_smx_status_n配置。

MOV指令可以以一些特定的方式对传输的数据进行操作，操作方式由 **Operation** 参数指定。按位取反操作可以对 **Source** 中的数据每一位都逻辑取反再传输到 **Destination** 中，比如在 **Source** 中为1则在 **Destination** 中变为0，反之亦然。假定数据以0~31位为例，位反转会将 **Source** 中第n位放到 **Destination** 中的第31-n位，

IRQ
^^^^

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|IRQ | 1  | 1  | 0  |     Delay/side-set     | 0  |Clr |Wait|         Index          |
+----+----+----+----+------------------------+----+----+----+------------------------+

IRQ指令的作用是根据 **Index** 参数置位或者清除IRQ标志位。

**Clear** ：如果该位为1，则清除 **Index** 指定的标志，如果该位为0，则置位 **Index** 指定的标志。一旦该位置位， **Wait** 域的参数就不生效。

**Wait** ：如果该位为1，则会暂定等待直到已经置位的该位又变成清零状态。

**Index** ：

- 指令中 **Index** 域的低3位指定被操作的标志位，可以是0~7，被指定的标志位根据 **Clear** 域决定对标志位进行置位或清零。
- 如果指令中 **Index** 域的最高位为1，那么状态机的序号和 **Index** 域的低3位相加的和再除以4得到的余数会对应实际操作的IRQ标志位，比如2号状态机执行IRQ指令且 **Index** 域的值为0x11则IRQ的第3位标志位被操作，2号状态机执行IRQ指令且 **Index** 域的值为0x13则IRQ的第1位标志位被操作。

IRQ的4~7标志位只对状态机可见，IRQ的0~3标志位不仅可以由状态机访问，也可以连接外部的系统中断，这通过IRQ0_INTE和IRQ1_INTE配置。

当多个状态机运行相同的程序时， **Index** 域的最高位为1的加状态机号再取模的机制可以让IRQ指令和WAIT指令在不同的状态机间进行同步，此时 **Index** 域的bit2没有影响。

当 **Wait** 被置位时，延时只有在等待标志位清零后才会开始。

SET
^^^^

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|Bit:| 15 | 14 | 13 | 12 | 11 | 10 | 9  | 8  | 7  | 6  | 5  | 4  | 3  | 2  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|SET | 1  | 1  | 1  |     Delay/side-set     | Destination  |          Data          |
+----+----+----+----+------------------------+--------------+------------------------+

SET指令的作用是将 **Data** 写入 **Destination** 。

**Destination** ：

- 000：PINS
- 001：暂存寄存器X的低5位被写入 **Data** ，其它位为0。
- 010：暂存寄存器Y的低5位被写入 **Data** ，其它位为0。
- 011：保留
- 100：PINDIRS（引脚输入输出方向）
- 101：保留
- 110：保留
- 111：保留

**Data** ：被写入引脚或寄存器的5-bit的立即数。

该指令可用于对时钟信号或片选信号等的控制，也可以用于初始化循环计数值等等，由于数据只有5位，所以暂存寄存器可以被初始化为0~31，这对于32次循环迭代足够了。

SET指令和OUT指令是使用独立的引脚映射配置的，它们可以映射到不同的位置，比如一个映射到时钟引脚另一个映射到数据引脚。它们之间也可以重叠映射，比如UART的发送可以将SET映射为引脚的停止位发送，而OUT映射为FIFO中数据的移位，但它们使用同一个引脚。

功能描述
----------

侧置（Side-set）
^^^^^^^^^^^^^^^^^^
侧置这种特性允许状态机在执行主要指令的同时修改多达5个引脚的电平和方向。一个有代表性的例子是在SPI接口中，在数据一位一位地从OSR发送到引脚的同时也需要翻转时钟信号，在这样的情况下，使用带有侧置特性的OUT指令就可以同时实现这两个功能。这使得接口的时序更加精确并能减小程序大小（因为不再需要一个独立的SET指令来翻转时钟引脚），也可以让SPI运行更高的时钟速率。侧置功能也能让引脚映射更加灵活，因为侧置的引脚映射和SET指令的引脚映射是互相独立的。

配置侧置的数据在每一条指令的 **Delay/side-set** 域中，任何一条指令都可以配置侧置功能，不管是用OUT还是SET指令操作引脚等等。侧置的引脚映射和OUT以及SET指令的引脚映射是独立的，它们的映射也可以重叠，如果OUT或SET指令的引脚和侧置映射的引脚冲突则侧置功能生效。

配置侧置功能有以下4步：

- 配置指令中 **Delay/side-set** 域的用于侧置功能而不是延时功能的高位位数，这由SMx_PINCTRL寄存器中cr_smx_sideset_count设定。如果设为5，那么延时就不可以设置，如果设置为0，将禁用侧置功能 。
- 配置是否使用 **Delay/side-set** 域的最高位为侧置使能位，这由SMx_EXECCTRL寄存器中cr_smx_side_en设置 。如果使能，则在每条指令中只有 **Delay/side-set** 域的最高位为1时侧置才生效。如果没有这一位的设置，那么每条指令都执行侧置功能。
- 通过SMx_PINCTRL寄存器中cr_smx_sideset_base设置侧置映射引脚的起始引脚号。
- 通过SMx_EXECCTRL寄存器中cr_smx_side_pindir设置侧置数据写入引脚电平值还是引脚方向。

时钟分频器
^^^^^^^^^^^
PEC运行的时钟与系统时钟分离，但是这对于很多接口来说实在太快了，此外插入的延时时间也是非常有限的。一些设备比如UART，其速率需要精确控制和改变，一种理想情况是多个状态机运行相同的程序，但它们可以独立修改速率。正是基于以上原因，每一个状态机都配备了一个时钟分频器。

时钟分频器并不是降低系统时钟本身，而是重新定义多个系统时钟周期为“一个周期”，它通过生成时钟使能信号来实现这一点，该信号可以在每个系统时钟周期的基础上暂停和恢复执行。时钟分频器定期生成时钟使能脉冲，以便状态机以某种稳定的速度运行，这可能比系统时钟慢的多。

以这种方式实现的分频器可以使状态机和系统之间的接口更加简单、延迟更低并且占用的空间更小。状态机在时钟使能信号为低时是完全空闲状态，但此时系统仍然可以访问状态机的FIFO并更改其配置。

时钟分频系数由SMx_CLKDIV寄存器设定，该寄存器为32位，其中16~31位为整数分频值，8~15位为小数分频值。整数分频值设为0时表示65536分频，小数分频值除以256即为实际小数值，将整数分频和小数分频组合后即为实际分频系数。

引脚映射
^^^^^^^^^
PEC在内部有一个 32 位寄存器，用于控制它可以驱动的每个 GPIO 的输出电平，以及另一个用于输出使能 (Hi/Lo-Z) 的寄存器。 在每个系统时钟周期，每个状态机都可以向这两个寄存器中的部分或全部GPIO写入数据。

写入输出电平寄存器和输出使能寄存器的数据可以有以下来源：

- OUT指令最多可以写入32位，根据指令中的Destination域，OUT指令可以向引脚电平和引脚方向寄存器写入数据，OUT指令输出数据的最低有效位映射到SMx_PINCTRL寄存器的cr_smx_out_base指定的引脚，并且连续映射SMx_PINCTRL寄存器的cr_smx_out_count指定的数量的引脚，引脚号到31后再绕回。
- SET指令最多可以写入5位，根据指令中的Destination域，SET指令可以向引脚电平和引脚方向寄存器写入数据，SET指令输出数据的最低有效位映射到SMx_PINCTRL寄存器的cr_smx_set_base指定的引脚，并且连续映射SMx_PINCTRL寄存器的cr_smx_set_count指定的数量的引脚，引脚号到31后再绕回。
- 侧置操作最多可以写入5位，根据SMx_EXECCTRL寄存器的cr_smx_side_pindir的设定，侧置可以向引脚电平和引脚方向寄存器写入数据，侧置输出数据的最低有效位映射到SMx_PINCTRL寄存器的cr_smx_sideset_base指定的引脚，并且连续映射SMx_PINCTRL寄存器的cr_smx_sideset_count指定的数量的引脚，需要注意的是如果SMx_EXECCTRL寄存器的cr_smx_side_en为1，则侧置的引脚数量需要减一。

每一个OUT/SET/side-set操作都会向连续的引脚写入数据，但是它们之间写入的引脚位置和个数是互相独立的，这对于很多应用场景都是非常灵活的。比如，一个状态机在基于一组引脚运行SPI的接口，另外一个状态机可以也运行相同的程序但是将引脚映射为另外一组，形成另一个SPI接口。

如果一个状态机在一个周期内执行的OUT或SET指令与侧置操作的引脚重叠，则侧置优先级更高。