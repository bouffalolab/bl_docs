<!DOCTYPE html>
<html class="writer-html5" lang="zh" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PEC &mdash; BL616/BL618 参考手册  文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> BL616/BL618 参考手册
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="在文档中搜索" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="SystemAndMemoryOverview.html">1. 系统和存储器概述</a></li>
<li class="toctree-l1"><a class="reference internal" href="ResetAndClock.html">2. 复位和时钟</a></li>
<li class="toctree-l1"><a class="reference internal" href="GLB.html">3. GLB</a></li>
<li class="toctree-l1"><a class="reference internal" href="GPIO.html">4. GPIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="ADC.html">5. ADC</a></li>
<li class="toctree-l1"><a class="reference internal" href="DAC.html">6. DAC</a></li>
<li class="toctree-l1"><a class="reference internal" href="DMA.html">7. DMA</a></li>
<li class="toctree-l1"><a class="reference internal" href="IR.html">8. IR</a></li>
<li class="toctree-l1"><a class="reference internal" href="SPI.html">9. SPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="UART.html">10. UART</a></li>
<li class="toctree-l1"><a class="reference internal" href="I2C.html">11. I2C</a></li>
<li class="toctree-l1"><a class="reference internal" href="PWM.html">12. PWM</a></li>
<li class="toctree-l1"><a class="reference internal" href="TIMER.html">13. TIMER</a></li>
<li class="toctree-l1"><a class="reference internal" href="I2S.html">14. I2S</a></li>
<li class="toctree-l1"><a class="reference internal" href="AudioDAC.html">15. AudioDAC</a></li>
<li class="toctree-l1"><a class="reference internal" href="AudioADC.html">16. AudioADC</a></li>
<li class="toctree-l1"><a class="reference internal" href="EMAC.html">17. Emac</a></li>
<li class="toctree-l1"><a class="reference internal" href="USB.html">18. USB</a></li>
<li class="toctree-l1"><a class="reference internal" href="ISO11898.html">19. ISO11898</a></li>
<li class="toctree-l1"><a class="reference internal" href="Cam.html">20. CAM</a></li>
<li class="toctree-l1"><a class="reference internal" href="MJPEG.html">21. MJPEG</a></li>
<li class="toctree-l1"><a class="reference internal" href="DBI.html">22. DBI</a></li>
<li class="toctree-l1"><a class="reference internal" href="SDH.html">23. SDH</a></li>
<li class="toctree-l1"><a class="reference internal" href="SDIO.html">24. SDIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="LowPower.html">25. LowPower</a></li>
<li class="toctree-l1"><a class="reference internal" href="SEC_ENG.html">26. SEC ENG</a></li>
<li class="toctree-l1"><a class="reference internal" href="version.html">27. 版本信息</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">BL616/BL618 参考手册</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>PEC</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pec">
<h1>PEC<a class="headerlink" href="#pec" title="永久链接至标题"></a></h1>
<section id="id1">
<h2>简介<a class="headerlink" href="#id1" title="永久链接至标题"></a></h2>
<p>PEC(Peripheral Expand Controller)是一种多功能的硬件接口，可以支持很多标准IO如8080/6800、I2C、3线I2S、SDIO、SPI/DSPI/QSPI、UART、DPI、VGA（配合电阻网络）等。PEC也像一般处理器那样可以编程，和一般处理器不一样的是PEC是为IO高度定制的，侧重于精确且严格的时序，并且是和固定功能的硬件紧密集成。</p>
</section>
<section id="id2">
<h2>主要特征<a class="headerlink" href="#id2" title="永久链接至标题"></a></h2>
<ul class="simple">
<li><p>4个可独立运行的状态机</p></li>
<li><p>32条指令储存空间</p></li>
<li><p>2组可自由配置的中断</p></li>
<li><p>16位指令宽度，9种类型指令</p></li>
<li><p>每条指令都可以设置延时并控制IO</p></li>
</ul>
<p>每个状态机的特征如下：</p>
<ul class="simple">
<li><p>2个32bits移位寄存器，可以任意方向移位，任意移动位数</p></li>
<li><p>2个32bits的暂存寄存器</p></li>
<li><p>每个方向都有8*32bits的FIFO</p></li>
<li><p>小数时钟分频（16位整数，8位小数）</p></li>
<li><p>灵活的GPIO映射</p></li>
<li><p>DMA接口</p></li>
<li><p>IRQ标志的置位、清除及获取</p></li>
</ul>
</section>
<section id="id3">
<h2>功能介绍<a class="headerlink" href="#id3" title="永久链接至标题"></a></h2>
<section id="id4">
<h3>编程模型<a class="headerlink" href="#id4" title="永久链接至标题"></a></h3>
<section id="id5">
<h4>控制流<a class="headerlink" href="#id5" title="永久链接至标题"></a></h4>
<p>每个状态机的取指、解码和执行都在一个时钟周期内完成，每条指令精确地需要一个周期，除非预期等待（比如WAIT指令）。指令也可以在执行完成后等待最多31个周期再执行下一条指令，这样可以避免增加延时的代码。程序计数器PC指向当前正在执行的指令所在的储存空间的位置，一般来说，PC每个周期会自增1，并且在指令存储空间的末尾绕回。跳转指令会精确地指定下一条指令执行的位置。</p>
</section>
<section id="id6">
<h4>寄存器<a class="headerlink" href="#id6" title="永久链接至标题"></a></h4>
<p>每个状态机都有一些内部寄存器，这些寄存器可用于储存输入输出的数据，或者存储例如用于循环次数的临时变量等。</p>
<p><strong>输出移位寄存器（OSR）</strong></p>
<figure class="align-center">
<img alt="../_images/PECOsr.svg" src="../_images/PECOsr.svg" /></figure>
<p>OSR用来保存并移位TX FIFO和引脚（也可以是其他目的地比如暂存寄存器）之间的数据。</p>
<ul class="simple">
<li><p>PULL指令可以将一个32位数据从TX FIFO拉取到OSR。</p></li>
<li><p>OUT指令可以一次将1~32位数据从OSR移位到其他目的地。</p></li>
<li><p>OSR中的数据被移出后用0补齐。</p></li>
<li><p>一旦使能了自动拉取，并且当移位的总数达到设定的阈值时，在OUT指令后状态机会自动用FIFO中的数据重新填充OSR。</p></li>
<li><p>处理器通过配置寄存器可以设定移位方向为向左或者向右。</p></li>
</ul>
<p><strong>输入移位寄存器（ISR）</strong></p>
<figure class="align-center">
<img alt="../_images/PECIsr.svg" src="../_images/PECIsr.svg" /></figure>
<ul class="simple">
<li><p>IN指令可以一次将1~32位数据移位到ISR。</p></li>
<li><p>PUSH指令可以将ISR中的数据写入到RX FIFO中。</p></li>
<li><p>ISR中的数据被推送后即被清零。</p></li>
<li><p>如果使能了自动推送，当移位的总数达到设定的阈值时，在IN指令后状态机会自动推送ISR中的数据。</p></li>
<li><p>处理器通过配置寄存器可以设定移位方向。</p></li>
</ul>
<p><strong>移位计数值</strong></p>
<p>状态机会将OUT指令移出OSR的位数和IN指令移入ISR的位数记录下来，这些信息由两个硬件计数器跟踪记录，计数值范围为0~32（移位寄存器的宽度）。状态机可以配置为在计数值达到阈值时做一些特定的如下动作：</p>
<ul class="simple">
<li><p>一旦移出位数达到阈值可以重新填充OSR。</p></li>
<li><p>一旦移入位数达到阈值，ISR可以被清空。</p></li>
<li><p>PUSH和PULL指令也可以配置为各自独立地依赖输入和输出的移位长度。</p></li>
</ul>
<p>PEC复位后或者使用cr_sm_reset进行复位后，ISR移位计数值会被清零即还没有移出，OSR移位计数值会被初始化为32即没有未移出的数据。其他一些指令也会影响移位计数值，包括如下：</p>
<ul class="simple">
<li><p>PULL指令会将输出移位计数值清零</p></li>
<li><p>PUSH指令会将输入移位计数值清零</p></li>
<li><p>MOV指令使用OSR作为目的地时会将输出移位计数器清零</p></li>
<li><p>MOV指令使用ISR作为目的地时会将输入移位计数器清零</p></li>
<li><p>OUT指令将ISR作为目的地时会将输入移位计数器的值设定为OUT指令中指定的值</p></li>
</ul>
<p><strong>暂存寄存器</strong></p>
<p>每个状态机都有两个内部暂存寄存器，被称为X和Y。这两个寄存器被用于以下场景：</p>
<ul class="simple">
<li><p>IN/OUT/SET/MOV指令的源和目的地</p></li>
<li><p>跳转的判断条件</p></li>
</ul>
<p><strong>先进先出缓冲区</strong></p>
<p>每一个状态机都有两个8字深度的先进先出缓冲区，一个用于从系统到状态机即发送，一个用于从状态机到系统即接收。发送缓冲区由处理器或DMA等主机控制器写入数据，接收缓冲区由状态机写入数据。缓冲区使状态机和系统总线的时序分离，允许状态机在没有处理器干预的情况下运行更长的时间。</p>
<p>缓冲区还可以生成数据请求信号，允许系统DMA控制器根据RX FIFO和TX FIFO中的数据目前占用状态来调整其读写速度，这允许处理器收发上千字节的数据而不需要处理器的干预。</p>
</section>
<section id="id7">
<h4>阻塞<a class="headerlink" href="#id7" title="永久链接至标题"></a></h4>
<p>状态机可能因为以下一些原因而阻塞：</p>
<ul class="simple">
<li><p>WAIT指令所需条件尚未满足</p></li>
<li><p>TX FIFO为空时PULL指令会阻塞，或者RX FIFO为满时PUSH指令会阻塞</p></li>
<li><p>IRQ指令将中断标志置位并等待其清零</p></li>
<li><p>当自动拉取使能时，OSR移位计数值已经达到阈值但TX FIFO为空时，OUT指令会阻塞</p></li>
<li><p>当自动推入使能时，ISR移位计数值已经达到阈值但RX FIFO为满时，IN指令会阻塞</p></li>
</ul>
<p>在以上所述情况下，程序计数器不会增加并且状态机在下一个周期仍然会执行该条指令。如果指令指明了延时周期则只有当阻塞取消后延时才会开始。</p>
</section>
<section id="id8">
<h4>引脚映射<a class="headerlink" href="#id8" title="永久链接至标题"></a></h4>
<p>PEC既可以控制多达32个GPIO口的输出电平高低和方向，也可以获取它们的输入电平，在每一个系统时钟周期，每个状态机可以操作如下属性或什么都不操作：</p>
<ul class="simple">
<li><p>通过OUT或SET指令改变一些GPIO的电平或方向，或者通过IN指令获取一些GPIO的状态</p></li>
<li><p>通过侧置功能操作一些GPIO的电平或方向</p></li>
</ul>
<p>以上操作都是控制连续的GPIO，这一连续GPIO的起始引脚和GPIO数量在每个状态机的PINCTRL寄存器中可以配置。OUT、SET、IN以及侧置功能都有各自独立的引脚映射关系，并且他们之间允许重叠。</p>
<p>对于每个单独的GPIO输出（包括电平和方向，他们是分开的），在一个周期内最多有4个状态机的同时写入操作，此时状态机序号最高的写入生效。如果一个状态机的SET/OUT指令和侧置功能同时操作同一个GPIO，则侧置功能生效。如果没有状态机对GPIO进行操作，则GPIO的值维持前一个周期的状态不会改变。</p>
<p>一般来说每个状态机的输出是映射到独立的GPIO上，用来实现一些外设接口。</p>
</section>
<section id="irq">
<h4>IRQ标志<a class="headerlink" href="#irq" title="永久链接至标题"></a></h4>
<p>IRQ标志是可以被状态机或系统置位或清除的标志位，一共有8个都可以被状态机读写的IRQ标志，其中低4位还可以通过IRQ0_INTE和IRQ1_INTE来控制是否产生PEC的中断请求。IRQ标志主要有以下两大用处：</p>
<ul class="simple">
<li><p>让状态机和系统中断相关联，并且状态机可以等待中断应答</p></li>
<li><p>让两个状态机之间同步执行</p></li>
</ul>
<p>状态机之间可以通过IRQ和WAIT指令进行交互。</p>
</section>
<section id="id9">
<h4>状态机间相互作用<a class="headerlink" href="#id9" title="永久链接至标题"></a></h4>
<p>指令储存空间被实现为1写4读的寄存器文件，因此4个状态机可以同时无阻塞地读取指令。对于多个状态机共用指令存储空间有以下3种使用方式：</p>
<ul class="simple">
<li><p>多个状态机使用相同的程序代码</p></li>
<li><p>多个状态机使用不同的程序代码</p></li>
<li><p>不同的状态机运行一个接口的不同部分，比如UART的发送和接收功能分离，或者DPI显示接口的时钟同步信号与像素数据信号分离</p></li>
</ul>
<p>状态机之间不能传输数据，但是它们之间可以通过IRQ标志位进行同步。一共有8个标志位（低4位可以被用来触发系统中断），每个状态机都可以通过IRQ指令置位或清除标志位，也可以使用WAIT指令等待标志位，这样的机制允许状态机之间实现精确的周期同步。</p>
</section>
</section>
<section id="id10">
<h3>指令集<a class="headerlink" href="#id10" title="永久链接至标题"></a></h3>
<section id="summary">
<h4>Summary<a class="headerlink" href="#summary" title="永久链接至标题"></a></h4>
<p>PEC指令长度为16位，编码格式如下表所示：</p>
<table class="docutils align-default" id="id15">
<caption><span class="caption-text">PEC指令编码表</span><a class="headerlink" href="#id15" title="永久链接至表格"></a></caption>
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>JMP</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Condition</p></td>
<td colspan="5"><p>Address</p></td>
</tr>
<tr class="row-odd"><td><p>WAIT</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td><p>Pol</p></td>
<td colspan="2"><p>Source</p></td>
<td colspan="5"><p>Index</p></td>
</tr>
<tr class="row-even"><td><p>IN</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Source</p></td>
<td colspan="5"><p>Bit count</p></td>
</tr>
<tr class="row-odd"><td><p>OUT</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Destination</p></td>
<td colspan="5"><p>Bit count</p></td>
</tr>
<tr class="row-even"><td><p>PUSH</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td><p>0</p></td>
<td><p>IfF</p></td>
<td><p>Blk</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>PULL</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td><p>1</p></td>
<td><p>IfE</p></td>
<td><p>Blk</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>MOV</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Destination</p></td>
<td><p>Op</p></td>
<td colspan="4"><p>Source</p></td>
</tr>
<tr class="row-odd"><td><p>IRQ</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td><p>0</p></td>
<td><p>Clr</p></td>
<td><p>Wait</p></td>
<td colspan="5"><p>Index</p></td>
</tr>
<tr class="row-even"><td><p>SET</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Destination</p></td>
<td colspan="5"><p>Data</p></td>
</tr>
</tbody>
</table>
<p>PEC的每条指令的执行都只需要一个时钟周期。</p>
<p>Delay/side-set域在每条指令中都存在，它的确切用途由每个状态机的PINCTRL寄存器中的sideset_count配置，具体描述如下：</p>
<ul class="simple">
<li><p>最多5位高位部分编码为侧置功能，侧置功能在一条指令执行的同时通过一个确定的值来控制一些GPIO</p></li>
<li><p>剩余的低位部分决定在下条指令执行前延时的周期数</p></li>
</ul>
</section>
<section id="jmp">
<h4>JMP<a class="headerlink" href="#jmp" title="永久链接至标题"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>JMP</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Condition</p></td>
<td colspan="5"><p>Address</p></td>
</tr>
</tbody>
</table>
<p>该指令的作用是当条件满足时，程序计数器将跳转到设定的地址处，如果条件没满足则不跳转。</p>
<p>需要注意的是不管条件是否成立，延时都会生效，延时从条件判断完并且程序计数器更新后开始。</p>
<p>判断条件（Condition）如下：</p>
<ul class="simple">
<li><p>000：永远跳转（没有条件）</p></li>
<li><p>001：!X，暂存寄存器X为0</p></li>
<li><p>010：X--，暂存寄存器X非零，并且判断后该寄存器自减一</p></li>
<li><p>011：!Y，暂存寄存器Y为0</p></li>
<li><p>100：Y--，暂存寄存器Y非零，并且判断后该寄存器自减一</p></li>
<li><p>101：X!=Y，暂存寄存器X和Y不相等</p></li>
<li><p>110：PIN，跳转引脚</p></li>
<li><p>111：!OSRE，输出移位寄存器非空</p></li>
</ul>
<p>地址（Address）：这是将要跳转的指令地址，在指令编码中，该地址是PEC指令储存器中的绝对地址。</p>
<p>跳转引脚（PIN）：该引脚由EXECTRL寄存器中的jmp_pin确定，如果该引脚为高电平则跳转。</p>
<p>输出移位寄存器非空（!OSRE）：将从上一次PULL后至现在移出的总位数和SHIFTCTL寄存器中的pull_thresh进行比较来进行判断OSR是否为空，这个阈值也是自动拉取的阈值。</p>
</section>
<section id="wait">
<h4>WAIT<a class="headerlink" href="#wait" title="永久链接至标题"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>WAIT</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td><p>Pol</p></td>
<td colspan="2"><p>Source</p></td>
<td colspan="5"><p>Index</p></td>
</tr>
</tbody>
</table>
<p>在条件满足前将一直阻塞。</p>
<p>和所有的阻塞指令一样，延时都是在指令完成后开始的，也就是说直到等待的条件满足后，延时才会开始。</p>
<p>极性（Pol）：</p>
<ul class="simple">
<li><p>1：等待1。</p></li>
<li><p>0：等待0。</p></li>
</ul>
<p>源（Source）：等待的对象，可以为以下描述的值：</p>
<ul class="simple">
<li><p>00：GPIO：由 <strong>Index</strong> 指定的系统GPIO输入引脚，这是GPIO的绝对序号，和状态机的输入引脚映射没有关系。</p></li>
<li><p>01：PIN：由 <strong>Index</strong> 指定的输入引脚，这是由输入引脚映射到的GPIO序号加上 <strong>Index</strong> 得到的引脚决定。</p></li>
<li><p>10：IRQ：由 <strong>Index</strong> 指定的IRQ标志位。</p></li>
<li><p>11：保留</p></li>
</ul>
<p>序号（Index）：决定等待的引脚序号。</p>
<p>等待IRQ标志的行为和等待其他源有点不一样，描述如下：</p>
<ul class="simple">
<li><p>如果极性（Pol）为1，则一旦等待条件满足时，被选择的IRQ标志位会被清除。</p></li>
<li><p>这里标志序号和IRQ指令的序号的解码方式是一样的，如果标志序号的最高位为1，则状态机的ID号将会与标志序号相加再除以4得到的余数作为IRQ的序号。比如2号状态机的序号值写0x11，则其将等待IRQ的第3位，2号状态机的序号值写0x13，则其将等待IRQ的第1位。这样的机制允许多个状态机运行同一个代码时进行同步。</p></li>
</ul>
</section>
<section id="in">
<h4>IN<a class="headerlink" href="#in" title="永久链接至标题"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>IN</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Source</p></td>
<td colspan="5"><p>Bit count</p></td>
</tr>
</tbody>
</table>
<p>将 <strong>Source</strong> 中的 <strong>Bit count</strong> 长度的位移位到ISR中，移位方向由每个状态机的SHIFTCTRL寄存器中的in_shiftdir配置，此外，输入移位计数值也会相应加上 <strong>Bit count</strong> ，饱和值为32。</p>
<p>源（Source）：</p>
<ul class="simple">
<li><p>000：PINS</p></li>
<li><p>001：X（暂存寄存器X）</p></li>
<li><p>010：Y（暂存寄存器Y）</p></li>
<li><p>011：NULL（全0）</p></li>
<li><p>100：保留</p></li>
<li><p>101：保留</p></li>
<li><p>110：ISR</p></li>
<li><p>111：OSR</p></li>
</ul>
<p>位数（Bit count）：移位到ISR的位数，范围为1~32，32用0表示。</p>
<p>如果使能了自动推送功能，则移位计数值达到推送阈值时，IN指令也会将数据从ISR推送到RX FIFO中，不管自动推送是否发生，IN指令的执行都只占用一个周期，如果RX FIFO已经满了，则状态机会阻塞。自动推送后，ISR中数据被清零并且输入移位计数值也清零。</p>
<p>IN指令总是将数据源中低 <strong>Bit count</strong> 位的数据作为有效数据，例如当寄存器SMx_PINCTRL中的cr_smx_in_base为5时，指令 <strong>IN 3, PINS</strong> 将会把PIN5~7的数据移位到ISR，ISR首先向左或向右移位以腾出输出数据的空间，然后输入数据会被拷贝到腾出的空间。需要注意的是输入数据的顺序和移位方向没有关系。</p>
<p>NULL也可以作为IN指令的输入源，比如对于UART接收来说总是先接收最低位，这就要求移位方向是向右移动。当使用IN指令从PIN脚获取8次数据后，这些数据将会在ISR的bit31~24，使用NULL作为数据源的IN指令向右移动24位，将使接收数据移动到bit7~0。当然也可以使用另一种方案，就是处理器或DMA从FIFO地址加3的位置获取FIFO中bit31~24位数据。</p>
</section>
<section id="out">
<h4>OUT<a class="headerlink" href="#out" title="永久链接至标题"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>OUT</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Destination</p></td>
<td colspan="5"><p>Bit count</p></td>
</tr>
</tbody>
</table>
<p>OUT指令的作用是将 <strong>Bit count</strong> 位的数据从OSR输出到 <strong>Destination</strong> 定义的目的地，此外该指令的执行也会使输出移位计数器的值增加 <strong>Bit count</strong> ，最多增加到32饱和。</p>
<p>目的地（Destination）：</p>
<ul class="simple">
<li><p>000：PINS</p></li>
<li><p>001：暂存寄存器X</p></li>
<li><p>010：暂存寄存器Y</p></li>
<li><p>011：NULL（放弃数据）</p></li>
<li><p>100：PINDIRS（引脚输入输出方向）</p></li>
<li><p>101：PC（程序计数器）</p></li>
<li><p>110：ISR（该操作会设置输入移位计数器的值为 <strong>Bit count</strong> ）</p></li>
<li><p>111：EXEC（将OSR移出的数据作为指令）</p></li>
</ul>
<p>位数（Bit count）：将要移出OSR的位数，范围为1~32，32用0表示。</p>
<p>OUT指令的作用是将一个32bits数据写入到目的地，其中低 <strong>Bit count</strong> 位部分来自OSR，剩余部分都是0。如果SMx_SHIFTCTL寄存器中的cr_smx_out_shiftdir设置为右移则这个数据是OSR的低位部分，如果cr_smx_out_shiftdir设置为左移则这个数据是OSR的高位部分。</p>
<p>目的地为PINS或PINDIRS时，使用 <strong>OUT</strong> 的引脚映射关系。</p>
<p>如果使能了自动拉取，一旦SMx_SHIFTCTRL寄存器中的cr_smx_pull_thresh设置的阈值达到，则OSR中的数据会自动被TX FIFO填充，同时输出移位计数器也会被清零。在这样的情况下，如果TX FIFO为空，则OUT指令会阻塞，否则仍会在一个周期内完成。</p>
<p>以EXEC作为目的地的OUT指令允许将指令包含在FIFO的数据流中，OUT指令本身执行需要一个周期，来自OSR中的指令将会在下一个周期执行。在这种机制下，对可以执行的指令没有特别的限制，但是OUT指令自身的延时会被忽略，被执行的指令可以正常插入延时。</p>
<p>以PC作为目的地的OUT指令类似于一条无条件跳转指令，跳转目的地为从OSR移出的输出数据作为偏移在指令储存地址中的对应地址。</p>
</section>
<section id="push">
<h4>PUSH<a class="headerlink" href="#push" title="永久链接至标题"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>PUSH</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td><p>0</p></td>
<td><p>IfF</p></td>
<td><p>Blk</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>PUSH指令的作用是将ISR中的数据以32bits推送到RX FIFO中，然后将ISR清零。</p>
<ul class="simple">
<li><p><strong>IfF</strong> （如果满，if full）：该位为1时，在总的输入移位计数值达到SMx_SHIFTCTRL寄存器中的cr_smx_push_thresh设定的阈值前，PUSH指令不生效，自动推送的机制也是这样的。</p></li>
<li><p><strong>Blk</strong> （阻塞，blocking）：该位为1时，如果RX FIFO已经满了，则会暂停执行。</p></li>
</ul>
</section>
<section id="pull">
<h4>PULL<a class="headerlink" href="#pull" title="永久链接至标题"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>PULL</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td><p>1</p></td>
<td><p>IfE</p></td>
<td><p>Blk</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>PULL 指令的作用是将一个32位的数据从TX FIFO加载到OSR中。</p>
<ul class="simple">
<li><p><strong>IfE</strong> （如果空， if empty）： 该位为1时，在总的输出移位计数值达到SMx_SHIFTCTRL寄存器中的cr_smx_pull_thresh设定的阈值前，PULL指令不生效，自动拉取的机制也是这样的。</p></li>
<li><p><strong>Blk</strong> （阻塞，blocking）：该位为1时，如果TX FIFO为空则暂停运行。该位为0时，如果TX FIFO为空则从暂存寄存器X取一个数据放到OSR中。</p></li>
</ul>
<p>一些外设比如UART或SPI等，当没有可用数据时应该暂停，当有数据到来时再将其取出进行操作，其他一些外设比如I2S应该连续运行，并且在没有可用数据时用占位符或重复数据来填充也比暂停更合适，这样的应用场景下用 <strong>Blk</strong> 参数就可以实现。</p>
<p>当TX FIFO为空时，一条不带阻塞的PULL指令和 <strong>MOV OSR,X</strong> 效果是一样的，程序可以给暂存寄存器X一个合适的预装值或者在每条不带阻塞的PULL指令后执行 <strong>MOV X,OSR</strong> ，这样可以在新的有效数据到来之前一直使用FIFO中的最后的有效数据。</p>
</section>
<section id="mov">
<h4>MOV<a class="headerlink" href="#mov" title="永久链接至标题"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>MOV</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Destination</p></td>
<td><p>Op</p></td>
<td colspan="4"><p>Source</p></td>
</tr>
</tbody>
</table>
<p>MOV指令的作用是将数据从 <strong>Source</strong> 复制到 <strong>Destination</strong> 。</p>
<p><strong>Destination</strong> ：</p>
<ul class="simple">
<li><p>000：PINS（和OUT指令使用相同的引脚映射）</p></li>
<li><p>001：暂存寄存器X</p></li>
<li><p>010：暂存寄存器Y</p></li>
<li><p>011：保留</p></li>
<li><p>100：EXEC（将数据作为指令执行）</p></li>
<li><p>101：PC（程序计数器）</p></li>
<li><p>110：ISR（输入移位计数器会被清零，也就是ISR为空）</p></li>
<li><p>111：OSR（输出移位计数器会被清零，也就是OSR满）</p></li>
</ul>
<p><strong>Operation</strong> ：</p>
<ul class="simple">
<li><p>00：常规操作</p></li>
<li><p>01：按位取反</p></li>
<li><p>10：位反转</p></li>
<li><p>11：保留</p></li>
</ul>
<p><strong>Source</strong> ：</p>
<ul class="simple">
<li><p>000：PINS（和IN指令使用相同的引脚映射）</p></li>
<li><p>001：暂存寄存器X</p></li>
<li><p>010：暂存寄存器Y</p></li>
<li><p>011：NULL（全0）</p></li>
<li><p>100：保留</p></li>
<li><p>101：FIFO状态</p></li>
<li><p>110：ISR</p></li>
<li><p>111：OSR</p></li>
</ul>
<p>以PC为目的地的MOV指令会引起无条件跳转。以EXEC为目的地的MOV指令和目的地为EXEC的OUT指令作用是一样的，这会将寄存器中的数据作为一条指令执行，MOV指令本身的执行占用一个周期， <strong>Source</strong> 指定的指令会紧接着在下一个周期执行，在这样的情况下指令中指明的延时会被忽略，但是指令中 <strong>Source</strong> 指定的指令的延时是生效的。</p>
<p>FIFO状态作为源时，其数据只有两种，要么是全0要么是全1，这和各自状态机的FIFO状态有关，这可以由SMx_EXECCTRL寄存器中cr_smx_status_sel与cr_smx_status_n配置。</p>
<p>MOV指令可以以一些特定的方式对传输的数据进行操作，操作方式由 <strong>Operation</strong> 参数指定。按位取反操作可以对 <strong>Source</strong> 中的数据每一位都逻辑取反再传输到 <strong>Destination</strong> 中，比如在 <strong>Source</strong> 中为1则在 <strong>Destination</strong> 中变为0，反之亦然。假定数据以0~31位为例，位反转会将 <strong>Source</strong> 中第n位放到 <strong>Destination</strong> 中的第31-n位，</p>
</section>
<section id="id11">
<h4>IRQ<a class="headerlink" href="#id11" title="永久链接至标题"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>IRQ</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td><p>0</p></td>
<td><p>Clr</p></td>
<td><p>Wait</p></td>
<td colspan="5"><p>Index</p></td>
</tr>
</tbody>
</table>
<p>IRQ指令的作用是根据 <strong>Index</strong> 参数置位或者清除IRQ标志位。</p>
<p><strong>Clear</strong> ：如果该位为1，则清除 <strong>Index</strong> 指定的标志，如果该位为0，则置位 <strong>Index</strong> 指定的标志。一旦该位置位， <strong>Wait</strong> 域的参数就不生效。</p>
<p><strong>Wait</strong> ：如果该位为1，则会暂定等待直到已经置位的该位又变成清零状态。</p>
<p><strong>Index</strong> ：</p>
<ul class="simple">
<li><p>指令中 <strong>Index</strong> 域的低3位指定被操作的标志位，可以是0~7，被指定的标志位根据 <strong>Clear</strong> 域决定对标志位进行置位或清零。</p></li>
<li><p>如果指令中 <strong>Index</strong> 域的最高位为1，那么状态机的序号和 <strong>Index</strong> 域的低3位相加的和再除以4得到的余数会对应实际操作的IRQ标志位，比如2号状态机执行IRQ指令且 <strong>Index</strong> 域的值为0x11则IRQ的第3位标志位被操作，2号状态机执行IRQ指令且 <strong>Index</strong> 域的值为0x13则IRQ的第1位标志位被操作。</p></li>
</ul>
<p>IRQ的4~7标志位只对状态机可见，IRQ的0~3标志位不仅可以由状态机访问，也可以连接外部的系统中断，这通过IRQ0_INTE和IRQ1_INTE配置。</p>
<p>当多个状态机运行相同的程序时， <strong>Index</strong> 域的最高位为1的加状态机号再取模的机制可以让IRQ指令和WAIT指令在不同的状态机间进行同步，此时 <strong>Index</strong> 域的bit2没有影响。</p>
<p>当 <strong>Wait</strong> 被置位时，延时只有在等待标志位清零后才会开始。</p>
</section>
<section id="set">
<h4>SET<a class="headerlink" href="#set" title="永久链接至标题"></a></h4>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Bit:</p></td>
<td><p>15</p></td>
<td><p>14</p></td>
<td><p>13</p></td>
<td><p>12</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>8</p></td>
<td><p>7</p></td>
<td><p>6</p></td>
<td><p>5</p></td>
<td><p>4</p></td>
<td><p>3</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-even"><td><p>SET</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td colspan="5"><p>Delay/side-set</p></td>
<td colspan="3"><p>Destination</p></td>
<td colspan="5"><p>Data</p></td>
</tr>
</tbody>
</table>
<p>SET指令的作用是将 <strong>Data</strong> 写入 <strong>Destination</strong> 。</p>
<p><strong>Destination</strong> ：</p>
<ul class="simple">
<li><p>000：PINS</p></li>
<li><p>001：暂存寄存器X的低5位被写入 <strong>Data</strong> ，其它位为0。</p></li>
<li><p>010：暂存寄存器Y的低5位被写入 <strong>Data</strong> ，其它位为0。</p></li>
<li><p>011：保留</p></li>
<li><p>100：PINDIRS（引脚输入输出方向）</p></li>
<li><p>101：保留</p></li>
<li><p>110：保留</p></li>
<li><p>111：保留</p></li>
</ul>
<p><strong>Data</strong> ：被写入引脚或寄存器的5-bit的立即数。</p>
<p>该指令可用于对时钟信号或片选信号等的控制，也可以用于初始化循环计数值等等，由于数据只有5位，所以暂存寄存器可以被初始化为0~31，这对于32次循环迭代足够了。</p>
<p>SET指令和OUT指令是使用独立的引脚映射配置的，它们可以映射到不同的位置，比如一个映射到时钟引脚另一个映射到数据引脚。它们之间也可以重叠映射，比如UART的发送可以将SET映射为引脚的停止位发送，而OUT映射为FIFO中数据的移位，但它们使用同一个引脚。</p>
</section>
</section>
<section id="id12">
<h3>功能描述<a class="headerlink" href="#id12" title="永久链接至标题"></a></h3>
<section id="side-set">
<h4>侧置（Side-set）<a class="headerlink" href="#side-set" title="永久链接至标题"></a></h4>
<p>侧置这种特性允许状态机在执行主要指令的同时修改多达5个引脚的电平和方向。一个有代表性的例子是在SPI接口中，在数据一位一位地从OSR发送到引脚的同时也需要翻转时钟信号，在这样的情况下，使用带有侧置特性的OUT指令就可以同时实现这两个功能。这使得接口的时序更加精确并能减小程序大小（因为不再需要一个独立的SET指令来翻转时钟引脚），也可以让SPI运行更高的时钟速率。侧置功能也能让引脚映射更加灵活，因为侧置的引脚映射和SET指令的引脚映射是互相独立的。</p>
<p>配置侧置的数据在每一条指令的 <strong>Delay/side-set</strong> 域中，任何一条指令都可以配置侧置功能，不管是用OUT还是SET指令操作引脚等等。侧置的引脚映射和OUT以及SET指令的引脚映射是独立的，它们的映射也可以重叠，如果OUT或SET指令的引脚和侧置映射的引脚冲突则侧置功能生效。</p>
<p>配置侧置功能有以下4步：</p>
<ul class="simple">
<li><p>配置指令中 <strong>Delay/side-set</strong> 域的用于侧置功能而不是延时功能的高位位数，这由SMx_PINCTRL寄存器中cr_smx_sideset_count设定。如果设为5，那么延时就不可以设置，如果设置为0，将禁用侧置功能 。</p></li>
<li><p>配置是否使用 <strong>Delay/side-set</strong> 域的最高位为侧置使能位，这由SMx_EXECCTRL寄存器中cr_smx_side_en设置 。如果使能，则在每条指令中只有 <strong>Delay/side-set</strong> 域的最高位为1时侧置才生效。如果没有这一位的设置，那么每条指令都执行侧置功能。</p></li>
<li><p>通过SMx_PINCTRL寄存器中cr_smx_sideset_base设置侧置映射引脚的起始引脚号。</p></li>
<li><p>通过SMx_EXECCTRL寄存器中cr_smx_side_pindir设置侧置数据写入引脚电平值还是引脚方向。</p></li>
</ul>
</section>
<section id="id13">
<h4>时钟分频器<a class="headerlink" href="#id13" title="永久链接至标题"></a></h4>
<p>PEC运行的时钟与系统时钟分离，但是这对于很多接口来说实在太快了，此外插入的延时时间也是非常有限的。一些设备比如UART，其速率需要精确控制和改变，一种理想情况是多个状态机运行相同的程序，但它们可以独立修改速率。正是基于以上原因，每一个状态机都配备了一个时钟分频器。</p>
<p>时钟分频器并不是降低系统时钟本身，而是重新定义多个系统时钟周期为“一个周期”，它通过生成时钟使能信号来实现这一点，该信号可以在每个系统时钟周期的基础上暂停和恢复执行。时钟分频器定期生成时钟使能脉冲，以便状态机以某种稳定的速度运行，这可能比系统时钟慢的多。</p>
<p>以这种方式实现的分频器可以使状态机和系统之间的接口更加简单、延迟更低并且占用的空间更小。状态机在时钟使能信号为低时是完全空闲状态，但此时系统仍然可以访问状态机的FIFO并更改其配置。</p>
<p>时钟分频系数由SMx_CLKDIV寄存器设定，该寄存器为32位，其中16~31位为整数分频值，8~15位为小数分频值。整数分频值设为0时表示65536分频，小数分频值除以256即为实际小数值，将整数分频和小数分频组合后即为实际分频系数。</p>
</section>
<section id="id14">
<h4>引脚映射<a class="headerlink" href="#id14" title="永久链接至标题"></a></h4>
<p>PEC在内部有一个 32 位寄存器，用于控制它可以驱动的每个 GPIO 的输出电平，以及另一个用于输出使能 (Hi/Lo-Z) 的寄存器。 在每个系统时钟周期，每个状态机都可以向这两个寄存器中的部分或全部GPIO写入数据。</p>
<p>写入输出电平寄存器和输出使能寄存器的数据可以有以下来源：</p>
<ul class="simple">
<li><p>OUT指令最多可以写入32位，根据指令中的Destination域，OUT指令可以向引脚电平和引脚方向寄存器写入数据，OUT指令输出数据的最低有效位映射到SMx_PINCTRL寄存器的cr_smx_out_base指定的引脚，并且连续映射SMx_PINCTRL寄存器的cr_smx_out_count指定的数量的引脚，引脚号到31后再绕回。</p></li>
<li><p>SET指令最多可以写入5位，根据指令中的Destination域，SET指令可以向引脚电平和引脚方向寄存器写入数据，SET指令输出数据的最低有效位映射到SMx_PINCTRL寄存器的cr_smx_set_base指定的引脚，并且连续映射SMx_PINCTRL寄存器的cr_smx_set_count指定的数量的引脚，引脚号到31后再绕回。</p></li>
<li><p>侧置操作最多可以写入5位，根据SMx_EXECCTRL寄存器的cr_smx_side_pindir的设定，侧置可以向引脚电平和引脚方向寄存器写入数据，侧置输出数据的最低有效位映射到SMx_PINCTRL寄存器的cr_smx_sideset_base指定的引脚，并且连续映射SMx_PINCTRL寄存器的cr_smx_sideset_count指定的数量的引脚，需要注意的是如果SMx_EXECCTRL寄存器的cr_smx_side_en为1，则侧置的引脚数量需要减一。</p></li>
</ul>
<p>每一个OUT/SET/side-set操作都会向连续的引脚写入数据，但是它们之间写入的引脚位置和个数是互相独立的，这对于很多应用场景都是非常灵活的。比如，一个状态机在基于一组引脚运行SPI的接口，另外一个状态机可以也运行相同的程序但是将引脚映射为另外一组，形成另一个SPI接口。</p>
<p>如果一个状态机在一个周期内执行的OUT或SET指令与侧置操作的引脚重叠，则侧置优先级更高。</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2022.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用了 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a>开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>