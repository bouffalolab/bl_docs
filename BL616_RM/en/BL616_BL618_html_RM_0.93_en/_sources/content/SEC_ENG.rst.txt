===========
SEC ENG
===========

Overview
=====
AES 
-------------
Advanced Encryption Standard (AES) is the most common type of symmetric encryption algorithm. Also known as Rijndael encryption algorithm in cryptography, it is a block encryption standard adopted by the U.S. federal government.

SHA
-------------
SHA256 is a variant of Secure Hash Algorithm 2 (SHA2). SHA2, the successor of SHA1, is a cryptographic hash function algorithm standard designed by the United States National Security Agency.
SHA2 has six different variants: SHA224, SHA256, SHA384, SHA512, SHA512/224, and SHA512/256.SHA-512/224 means that the result takes the first 224 bits of SHA-512, and SHA-512/256 means that the result takes the first 256 bits of SHA-512.

CRC
-------------
Cyclic Redundancy Check (CRC) is a channel coding technique that generates short fixed-digit check codes based on data including network packets or computer files. It is mainly used to detect or check possible errors after data transfer or storage. It detects errors based on the principle of division and remainder.

GMAC
-------------
GMAC is to use Galois Field (GF, finite field) multiplication to calculate the MAC value of a message.

Features
=========
- Support AES-128, AES-192, AES-256 encryption and decryption
- Support SHA-256, SHA-512
- Support CRC-16, CRC-32
- Support GMAC
- Support True Random Number Generator(TRNG)

Principle
===========
AES encryption and decryption process
---------------
AES means that the same key is used for encryption and decryption, with encryption process as follows:

.. figure:: ../../picture/SecEngAes.svg
   :align: center

   AES Encryption Process

The following briefs the functions and significance of each part:

- Plaintext (P): unencrypted data.

- Key (K): The key used to encrypt plaintext. In symmetric encryption algorithm, encryption and decryption share one key. The key is generated by negotiation between the receiver and the sender, but it cannot be directly transmitted over network. Otherwise it will leak the key. Usually, the key is encrypted by an asymmetric encryption algorithm, and then transmitted to the other side over network, or the key is discussed face to face. The key must not be leaked. Otherwise the attacker will restore the ciphertext and steal confidential data.

- AES encryption function: Let this function be E, then C = E(K, P), where P, K and C denote plaintext, key, and ciphertext, respectively. That is, if plaintext (P) and key (K) are input as the parameters of function, this function will output ciphertext (C).

- Ciphertext (C): data processed by encryption function.

- AES decryption function: Let this function be D, then P = D(K, C), where C, K, and P denote ciphertext, key, and plaintext, respectively. That is, if ciphertext (C) and key (K) are input as the parameters of function, this function will output plaintext (P).

Implementation of SHA256
--------------------------

Its rule of data padding is the same as that of MD5. SHA256 uses 8 initial hash values and 64 hash constants.

The 8 initial hash values are as follows:

 - h0 = 0x6a09e667
 - h1 = 0xbb67ae85
 - h2 = 0x3c6ef372
 - h3 = 0xa54ff53a
 - h4 = 0x510e527f
 - h5 = 0x9b05688c
 - h6 = 0x1f83d9ab
 - h7 = 0x5be0cd19

These initial values are obtained by taking the first 32 bits from the decimal part of the square root of the first 8 prime numbers (2, 3, 5, 7, 11, 13, 17, and 19) in natural numbers.

The 64 constants are as follows:

- 428a2f98 71374491 b5c0fbcf e9b5dba5
- 3956c25b 59f111f1 923f82a4 ab1c5ed5
- d807aa98 12835b01 243185be 550c7dc3
- 72be5d74 80deb1fe 9bdc06a7 c19bf174
- e49b69c1 efbe4786 0fc19dc6 240ca1cc
- 2de92c6f 4a7484aa 5cb0a9dc 76f988da
- 983e5152 a831c66d b00327c8 bf597fc7
- c6e00bf3 d5a79147 06ca6351 14292967
- 27b70a85 2e1b2138 4d2c6dfc 53380d13
- 650a7354 766a0abb 81c2c92e 92722c85
- a2bfe8a1 a81a664b c24b8b70 c76c51a3
- d192e819 d6990624 f40e3585 106aa070
- 19a4c116 1e376c08 2748774c 34b0bcb5
- 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
- 748f82ee 78a5636f 84c87814 8cc70208
- 90befffa a4506ceb bef9a3f7 c67178f2

Similarly, these constants are obtained by taking the first 32 bits from the decimal part of the cube root of the first 64 prime numbers (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97...) in natural numbers.

SHA256 hash function:

 - Ch(x,y,z)=(x∧y)⊕(¬x∧z)
 - Ma(x,y,z)=(x∧y)⊕(x∧z)⊕(y∧z)
 - Σ0(x)=S \ :sup:`2` (x)⊕S \ :sup:`13` (x)⊕S \ :sup:`22` (x)
 - Σ1(x)=S \ :sup:`6` (x)⊕S \ :sup:`11` (x)⊕S \ :sup:`25` (x)
 - σ0(x)=S \ :sup:`7` (x)⊕S \ :sup:`18` (x)⊕R \ :sup:`3` (x)
 - σ1(x)=S \ :sup:`17` (x)⊕S \ :sup:`19` (x)⊕R \ :sup:`10` (x)

 - ∧: bitwise "AND"
 - ¬: bitwise "Padding"
 - ⊕: bitwise "Exclusive OR"
 - S \ :sup:`n` : Circularly shift right by n bits
 - R \ :sup:`n` : Shift right by n bits

Principle of GMAC
-------------
Authentication is actually a redundant message generated against the message itself, that is, the message authentication code (MAC). MAC is a technique for authenticating the integrity of a message. In cryptography, MAC refers to a verification mechanism used by both communication entities and a tool to ensure the integrity of message data.
MAC is a hash function with a key. But why does it need a key? The reason is that the message can be tampered with during transmission, so can the hash value. Therefore, to ensure a valid hash value, the hash value is protected by encryption, so that the receiver can judge the integrity of the whole message through the hash value upon reception, thus completing information transfer.

The MAC process is shown as follows:

.. figure:: ../../picture/SecEngMac.svg
   :align: center

   MAC Flow Chart

1. The sender and the receiver share the key K in advance (keep KEY1 and KEY2 values in the above figure consistent).

2. The sender calculates the MAC value based on the message (KEY1 is used to calculate the MAC1 for the original message).

3. The sender sends the original message and MAC1 to the receiver.

4. The receiver calculates MAC2 using KEY2 based on the received original message .

5. The receiver compares the calculated MAC2 with the MAC1 received from the sender.

6. If the MAC is consistent, the receiver can judge that the message is indeed from the sender (authentication succeeded) and has not been tampered with or there is a transmission error. If not, the message is not from the sender (authentication failed).

Note: It is recommended that the sender and the receiver store the KEY in the hardware security module, and the MAC value also shall be calculated in that module, to ensure the security of KEY, for example, in the encrypted chip.

GMAC is to use Galois Field (GF, finite field) multiplication to calculate the MAC value of a message.

Functional Description
===========

AES Accelerator
-------------
1. AES accelerator supports AES128/192/256 encryption and decryption.

- Configure se_aes_0\_mode and se_aes_0\_dec_en in the register se_aes_0\_ctrlL, as shown below:

.. figure:: ../../picture/SecEngAesMode.svg
   :align: center

   AES Operation Modes

Configure se_aes_0\_block_mode in the register se_aes_0\_ctrlL to select among different encryption modes including ECB, CTR, CBC, and XTS.

2. Key, plaintext, ciphertext, and initialization vector

- The register se_aes_0\_msa stores the address of plaintext or ciphertext.

- The register se_aes_0\_msa stores the address of ciphertext or plaintext.

- The register se_aes_0\_iv_0\~se_aes_0\_iv_3 stores IV.

- The register se_aes_0\_key_0\~se_aes_0\_key_7 stores the key.

3. Software and hardware encryption process

- Configure the register se\_aes\_0\_endian, including se\_aes\_0\_dout\_endian, se\_aes\_0\_din\_endian, se\_aes\_0\_key\_endian, se\_aes\_0\_iv\_endian, and se\_aes\_0\_twk\_endian; the value of 0 indicates "littleendian" and the value of 1 indicates "bigendian"

- Configure se\_aes\_0\_block\_mode in the register se\_aes\_0\_ctrl

- Configure se\_aes\_0\_mode in the register se\_aes\_0\_ctrl

- Configure se\_aes\_0\_dec\_en in the register se\_aes\_0\_ctrl

- Configure se\_aes\_0\_dec\_key\_sel in the register se\_aes\_0\_ctrl; 0 means using a new key, and 1 means using the same key as the last time

- Configure se\_aes\_0\_iv\_sel in the register se\_aes\_0\_ctrl; 0 means using a new iv, and 1 means using the same iv as the last time

- Enable AES by configuring se\_aes\_0\_en in the register se\_aes\_0\_ctrl

- Configure the register se\_aes\_0\_iv\_0~se\_aes\_0\_iv\_3 to set IV; the sequence of filling for MSB is se\_aes\_0\_iv\_0~se\_aes\_0\_iv\_3 and that for LSB is se\_aes\_0\_iv\_3~se\_aes\_0\_iv\_0

- Configure the register se\_aes\_0\_key\_0~se\_aes\_0\_key\_7 to set key; the sequence of filling for MSB is se\_aes\_0\_key\_0~se\_aes\_0\_key\_7 and that for LSB is se\_aes\_0\_key\_7~se\_aes\_0\_key\_0. Take first 4 bits for AES128, first 6 bits for AES196, and first 8 bits for AES256

- Configure the register se\_aes\_0\_msa to set the source address of the data to be processed

- Configure the register se\_aes\_0\_mda to set the destination address where the processing results are stored

- Configure se\_aes\_0\_msg\_len in the register se\_aes\_0\_ctrl to set the length of the data to be processed, in units of 128 bit

- Configure se\_aes\_0\_trig\_1t in the register se\_aes\_0\_ctrl to trigger AES

- The output result is stored in the address corresponding to the register se\_aes\_0\_mda

SHA Accelerator
-------------
SHA Accelerator
-------------
1. SHA accelerator supports 7 standard operations:

 - SHA-1、SHA-224、SHA-256、SHA-512、SHA-384、SHA-512/224、SHA-512/256，同时还支持MD5、CRC16、CRC32。

The se_sha_0\_mode in the register se_sha_0\_ctrl:   0:SHA-256 1:SHA-224 2:SHA-1 3:SHA-1 4:SHA-512 5:SHA-384 6:SHA-512/224 7:SHA-512/256

The se_sha_0\_mode_ext in the register se_sha_0\_ctrl: hash mode extention; 0:SHA 1:MD5 2:CRC-16 3:CRC-32

Configure se_sha_0\_mode in the register se_sha_0\_ctrl to select among different SHA operations, and configure se_sha_0\_mode_ext in the register se_sha_0\_ctrl to select among MD5, CRC16, and CRC32

- The se_sha_0\_mode is valid when se_sha_0\_mode_ext is 0.

- The se_sha_0\_mode is invalid when se_sha_0\_mode_ext is not 0.

2. Plaintext and ciphertext

- The register se_sha_0\_msa stores the plaintext address.

- The register se_sha_0\_hash_l\_0\~se_sha_0\_hash_l\_7 stores the ciphertext.

Sequence: MSB: se_sha_0\_hash_l\_0\~se_sha_0\_hash_l\_7; LSB: se_sha_0\_hash_l\_7\~se_sha_0\_hash_l\_0

3. Operation flow

- Configure se\_sha\_0\_mode in the register se\_sha\_0\_ctrl to set the specific mode of SHA

- Enable SHA by configuring se\_sha\_0\_en in the register se\_sha\_0\_ctrl

- Configure se\_sha\_0\_hash\_sel in the register se\_sha\_0\_ctrl; 0 means starting a new HASH calculation, and 1 means using the last result for HASH calculation

- Configure the register se\_sha\_0\_msa to set the source address of the data to be processed

- Configure se\_sha\_0\_msg\_len in the register se\_sha\_0\_ctrl to set the length of the data to be processed (512 bits for SHA1, SHA224 and SHA256, while 1024 bits for SHA512, SHA384, SHA512/224, and SHA512/256)

- Configure se\_sha\_0\_trig\_1t in the register se\_sha\_0\_ctrl to trigger SHA

- The output result is stored in se\_sha\_0\_hash\_l\_0~se\_sha\_0\_hash\_l\_7, MSB:se\_sha\_0\_hash\_l\_0~se\_sha\_0\_hash\_l\_7, LSB:se\_sha\_0\_hash\_l\_7~se\_sha\_0\_hash\_l\_0

GMAC(link Mode)
--------------------------
1. Definition of GMAC_link_Table Structure

 - Word0:

     + [9]:se_gmac_0_int_clr_1t
     + [10]:se_gmac_0_int_set_1t
     + [31:16]:se_gmac_0_msg_len

 - Word1:se_gmac_0_msa
 - Word2、Word3、Word4、Word5：se_gmac_0_h
 - Word6、Word7、Word8、Word9：se_gmac_0_tag

2. Usage process

- Configure se_gmac_0\_x_endian, se_gmac_0\_h_endian, and se_gmac_0\_t_endian 0:littleendian 1:bigendian in the register se_gmac_0\_ctrl_0

- Write the start address of the GMAC_link_Table structure into the register se_gmac_0\_lca

- Assign the original message address to se_gmac_0\_msa in Word1 in GMAC_link_Table structure

- Assign the original message length to se_gmac_0\_msg_len in Word0 in GMAC_link_Table structure, where the 128-bit message length corresponds to 1 in se_gmac_0\_msg_len

- Configure se_gmac_0\_trig_1t trigger gmac engine in the register se_gmac_0\_ctrl_0

- The output result is stored in Word6–Word9 in the GMAC_link_Table structure

Random Number Generator (RNG)
-------------
1. The random numbers generated by the built-in true RNG can be used as the basis for encryption and other operations.

- True random numbers: They are generated through physical phenomena, such as coin tossup, dicing, wheel rotation, noise from using electronic components, and nuclear fission. Such RNGs are called physical RNGs, and their weaknesses are high technical requirements.

- Pseudo-random numbers: Truly random numbers (or random events) are randomly generated in a generation process according to the distribution probability shown in the experimental process, and the result is unpredictable and invisible. The random function in the computer is simulated according to a specified algorithm, and its result is deterministic and visible. We may consider that the probability of this foreseeable result is 100%. Hence the "random number" generated by computer random function is not truly random, but pseudo-random.

2. Output

- The register SE\_TRNG\_0\_DOUT\_0~SE\_TRNG\_0\_DOUT\_7 stores the output random numbers.

3. Usage process

- Enable TRNG by configuring se\_trng\_0\_en in the register se\_trng\_0\_ctrl\_0

- Configure se\_trng\_0\_trig\_1t in the register se\_trng\_0\_ctrl\_0 to trigger TRNG

- The output result is stored in se\_trng\_0\_dout\_0~se\_trng\_0\_dout\_7

