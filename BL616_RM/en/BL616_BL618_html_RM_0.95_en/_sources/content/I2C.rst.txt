==========
I2C
==========

Overview
=====
Inter-Integrated Circuit (I2C) is a serial communication bus, which uses a multi-slave and multi-master architecture and is connected to low-speed peripherals.
Each device has a unique address identifier and can be used as a transmitter or receiver. The address of each device connected to the bus can be set by software through a unique address and the existing master or slave relation. The master can work as a master transmitter or a master receiver.
If two or more masters are initialized at the same time, data can be prevented from being damaged through conflict detection and arbitration during transmission.

BL616/BL618 has two I2C controller masters, whose slaveAddr, subAddr, and data to be transferred can be flexibly configured, to facilitate communication with slaves. With the FIFO of 2-word depth and interrupt function, it can be used with DMA to improve efficiency and supports flexible adjustment of clock frequency.

Features
=========
- Master mode
- Multi-master mode and arbitration function
- Flexible control of the level duration of the start, end and data transmission phases in segments
- Supports 7-bit address mode and 10-bit address mode
- Supports DMA transfer mode
- Supports multiple interrupt mechanisms

Functional Description
==========

.. table:: I2C pin list
    :widths: 30, 30, 40
    :width: 80%
    :align: center

    +----------+--------------+---------------------------+
    |   Name   |   Type       |    Description            |
    +==========+==============+===========================+
    | I2Cx_SCL | Input/output | I2C serial clock signal   |
    +----------+--------------+---------------------------+
    | I2Cx_SDA | Input/output | I2C serial data signal    |
    +----------+--------------+---------------------------+

Start and stop conditions
-----------------
All transmissions start with a START condition and end with a STOP condition.
The START and STOP conditions are generally generated by the master. The bus is considered to be busy after the START condition and to be idle for a certain period of time after the STOP condition.

START condition: SDA produces a high-to-low level transition when SCL is high;

STOP condition: SDA produces a low-to-high level transition when SCL is high.

Waveform diagram:

.. figure:: ../../picture/I2CStopStart.svg
   :align: center

   Start and stop conditions of I2C

Data Transfer Format
----------------

1. 7-bit address mode:

The first 8 bits transferred are addressing bytes, including a 7-bit slave address and a 1-bit direction bit.
Sending or receiving data by the master is controlled by the 8th bit in the first byte sent by the master.
If it is 0, it means that the data is sent by the master, while "1" indicates that data is received by the master.
After the direction bit is the answer bit (ACK), which is sent by the slave to answer (pull the signal low) and the host starts transmitting the specified length of data after receiving the answer.
Upon data transfer completed, the master sends out a STOP signal, with waveform shown below:

.. figure:: ../../picture/I2CMasterTxSlaveRx.svg
   :align: center

   Master transmit and slave receive data formats

.. figure:: ../../picture/I2CMasterRxSlaveTx.svg
   :align: center

   Master receive and slave transmit data formats

**Master Transmit and Slave Receive Timing**

.. figure:: ../../picture/I2CMasterTxSlaveRxSequence.svg
   :align: center

   Timing of master transmitter and slave receiver

**Master Receive and Slave Transmit Timing**

.. figure:: ../../picture/I2CMasterRxSlaveTxSequence.svg
   :align: center

   Timing of master receiver and slave transmitter

2. 10-bit address mode

The cr_i2c_10b_addr_en in the register i2c_config must be set to 1 before use.

The 10-bit slave address consists of the two bytes after the START condition (S) or the repeated START condition (Sr).
The first 7 bits of the first byte are 1111 0XX, where XX are the first two bits of MSB of the 10-bit address.
The 8th bit of the first byte is the read/write bit that determines the transfer direction.
The second byte is the remaining low 8 bits of the 10 bit address. The data transfer format is as follows.

.. figure:: ../../picture/I2CMasterToSlave10BitAddress.svg
   :align: center

   Master transmit and slave receive data format (10bit slave address)

When receiving the 10-bit address following the START condition, the slave compares the first byte (1111 0XX) of the slave address with its own address, and checks whether the eighth bit (read/write bit) is 0.
If the value of XX in the first byte is the same as the top two bits of the slave's 10 bit address, the first byte match passes and the slave will give answer A. If there are multiple slave devices connected to the bus, more than one device may match and generate answer A.
Next, all slaves start to match the second byte (XXXX XXXX), where only one slave will have the exact same lower eight bits of the 10 bit address as the second byte, and that slave will give answer A.
The slave that is addressed by the master will remain addressed until it receives a termination condition or a repeat start condition.

.. figure:: ../../picture/I2CSlaveToMaster10BitAddress.svg
   :align: center

   Master receive and slave transmit data format (10bit slave address)

Before the second acknowledgement A, the process is the same as that of the master-transmitter addressing the slave-receiver.
After the repeated START condition (Sr), the matched slave will remain in the addressed state.
This slave will check whether the first 7 bits of the first byte after Sr are 1111 0XX, and then test whether the 8th bit is 1 (read).
If this also matches, the slave considers that it is addressed as a transmitter and generates an acknowledgement (A).
The slave-transmitter will remain in the addressed state until it receives the STOP condition (P) or the repeated START condition (Sr) followed by a different slave address.
Then, under Sr, all the slaves will compare their addresses with 11110XX and test the eighth bit (read/write bit).
However, they will not be addressed, because for 10-bit devices, the read/write bit is 1, or for 7-bit devices, the slave addresses of 1111 0XX do not match.

Arbitration
------------
When there are multiple masters on I2C bus, it may happen that multiple masters start data transfer at the same time. At this time, the arbitration mechanism will decide which master has the right to transfer data, while other masters have to give up the control of the bus and wait until the bus is idle before transferring data again.

During data transfer, all masters must check whether the SDA is consistent with the data they want to send when SCL stays high. When the SDA level is different from the expected one, it means that other masters are transferring data at the same time. The masters with different SDA levels will lose the arbitration and other masters will complete the data transfer.

The waveform of two masters transferring data and initiating the arbitration mechanism at the same time is as follows:

.. figure:: ../../picture/I2CTxRxTogether.svg
   :align: center

   Waveform of simultaneous data transfer


I2C Clock Setting
==================

I2C clock can be derived from bclk (bus clock) and xclk, and frequency division can be done on this basis.
The duration of the start condition, each bit of data and the end condition are set by registers i2c_prd_start, i2c_prd_data and i2c_prd_stop respectively.
Each of these durations can be subdivided into 4 phases, and the number of samples in each phase is controlled by a separate byte in the register (the actual value is the register value plus 1). The 4 phase settings in the data section together determine the frequency division factor of the i2c clock.
As shown in the figure below, suppose the I2C clock source is selected as 80M bclk and the register i2c_prd_data is set to 0x09070b09, then the second 0 in the figure is 0x09+1=0x0a, the second 1 is 0x07+1=0x08, the second 2 is 0x0b+1=0x0c, and the second 3 is 0x09+1=0x0a.
Then the clock frequency of I2C is 80MHz/(0x0a+0x08+0x0c+0x0a) = 2MHz.
Similarly, the first 0, 1, 2 and 3 are set by register i2c_prd_start, which determines the duration of the start condition, and the third 0, 1, 2 and 3 are set by register i2c_prd_stop, which determines the duration of the end condition.

.. figure:: ../../picture/I2CClock.svg
   :align: center

   I2C clock setting

I2C Configuration Flow
========================

Configuration Items
------------------

- Read/write flag bit
- Slave address
- Slave register address
- Slave register address length
- Data (TX: configure the sent data; RX: store the received data)
- Data length
- Enable signal

Read/Write Flag Bit
-------------------------

I2C supports TX and RX working statuses. The cr_i2c_pkt_dir in the register i2c_config represents the TX/RX status, "0" for TX status and "1" for RX status.

Slave Address
-----------

Each slave connected to I2C will have a unique device address, which is usually 7 bits long. This address will be written into the cr_i2c_slv_addr in the register i2c_config. I2C will automatically shift to the left by 1 bit before sending the address, and the TX/RX direction bit will be added to the LSB.

Slave Register Address
-----------------

The slave register address represents the register address where I2C needs to read and write a slave register. The slave register address is written to the register i2c_sub_addr, and the cr_i2c_sub_addr_en in the register i2c_config must be set to 1.
If cr_i2c_sub_addr_en in the register i2c_config is set to 0, the I2C master will skip the slave register address field when sending.

Slave Register Address Length
----------------------

The slave register address length is subtracted by 1 and then written to cr_i2c_sub_addr_bc in the register i2c_config.

Data
--------

It refers to the data that needs to be sent to or received from the slave.
When sending data, I2C must write the data (in word) into the register i2c_fifo_wdata.
When receiving data, I2C must read out the data (in word) from the register i2c_fifo_rdata.

Data Length
---------

The cr_i2c_pkt_len in the i2c_config register sets the send data length (the value written to the register + 1 is the send data length), and the maximum send length is 256 bytes.

Enable Signal
---------

After the above items are configured, when cr_i2c_m\_en in the enable signal register i2c_config is set to 1, the I2C sending process will be started automatically.

When the read/write flag bit is configured as 0, I2C sends data. Take sending 2 bytes as an example, the master's transmission flow is as follows:

1. Start bit

2. (The slave address shifts to the left by 1 bit + 0) + ACK

3. Slave register address + ACK

4. 1-byte data + ACK

5. 1-byte data + ACK

6. Stop bit

When the read/write flag bit is configured as 1, I2C receives data. Take receiving 2 bytes as an example, the master's transmission flow is as follows:

1. Start bit

2. (The slave address shifts to the left by 1 bit + 0) + ACK

3. Slave register address + ACK

4. Start bit

5. (The slave address shifts to the left by 1 bit + 1) + ACK

6. 1-byte data + ACK

7. 1-byte data + ACK

8. Stop bit

FIFO Management
============

I2C FIFO has a 2-word depth, and I2C includes RX FIFO and TX FIFO.
The rx_fifo_cnt in the register i2c_fifo_config_1 represents how much data (in word) in RX FIFO needs to be read.
The tx_fifo_cnt in the register i2c_fifo_config_1 represents how much free space (in word) in TX FIFO for writing.

I2C FIFO status:

- RX FIFO underflow: When the data in RX FIFO is completely read out or empty, if I2C continues to read data from RX FIFO, the rx_fifo_underflow in the register i2c_fifo_config_0 will be set to 1;

- RX FIFO overflow: When I2C receives data until the two words of RX FIFO are filled, without reading RX FIFO, if I2C receives data again, the rx_fifo_overflow in the register i2c_fifo_config_0 will be set to 1;

- TX FIFO underflow: When the data size filled into TX FIFO does not meet the configured I2C data length: cr_i2c_pkt_len in i2c_config, and no new data is filled into TX FIFO, the tx_fifo_underflow in the register i2c_fifo_config_0 will be set to 1;

- TX FIFO overflow: After the two words of TX FIFO are filled, before the data in TX FIFO is sent out, if data is filled into TX FIFO again, the tx_fifo_overflow in the register i2c_fifo_config_0 will be set to 1.

Use with DMA
============

I2C can send and receive data through DMA. Setting i2c_dma_tx_en in the register i2c_fifo_config_0 to 1 will enable the DMA TX mode. After the channel for I2C is allocated, DMA will transfer data from memory to the i2c_fifo_wdata register.
Setting i2c_dma_rx_en in the register i2c_fifo_config_0 to 1 will enable the DMA RX mode. After the channel for I2C is allocated, DMA will transfer the data in the register i2c_fifo_rdata to memory.
When I2C is used with DMA, DMA will automatically transfer data, so it is unnecessary for CPU to write data into I2C TX FIFO or read data from I2C RX FIFO.

DMA Sending Flow
-------------

1. Set read/write flag bit to 0

2. Set slave address

3. Set slave register address

4. Set slave register address length

5. Data Length

6. Set enable signal register to 1

7. Configure DMA transfer size

8. Configure the transfer width of DMA source address

9. Configure the transfer width of DMA destination address (when I2C is used with DMA, the transfer width of destination address must be set to 32 bits, which is word-aligned)

10. Configure the DMA source address as the memory address for storing sent data

11. Configure the DMA destination address to I2C TX FIFO address, i2c_fifo_wdata

12. Enable DMA

DMA Receiving Flow
----------------

1. Set read/write flag bit to 1

2. Set slave address

3. Set slave register address

4. Set slave register address length

5. Data Length

6. Set enable signal register to 1

7. Configure DMA transfer size

8. Configure the transfer width of DMA source address (when I2C is used with DMA, the transfer width of source address must be set to 32 bits, which is word-aligned)

9. Configure the transfer width of DMA destination address

10. Configure the DMA source address to I2C RX FIFO address, i2c_fifo_rdata

11. Configure the DMA destination address as the memory address for storing received data

12. Enable DMA

Interrupt
============

I2C includes the following interrupts:

- I2C_TRANS_END_INT
  * I2C transfer end interrupt, which is generated when I2C completes a transfer
- I2C_TX_FIFO_READY_INT
  * When tx_fifo_cnt in i2c_fifo_config_1 is greater than tx_fifo_th, a TX FIFO request interrupt will be generated, and the interrupt flag will be automatically cleared when the condition is not satisfied
- I2C_RX_FIFO_READY_INT
  * When rx_fifo_cnt in i2c_fifo_config_1 is greater than rx_fifo_th, an RX FIFO request interrupt will be generated, and the interrupt flag will be automatically cleared when the condition is not satisfied
- I2C_NACK_RECV_INT
  * When the I2C module detects a NACK state, a NACK interrupt is generated
- I2C_ARB_LOST_INT
  * I2C arbitration lost interrupt
- I2C_FIFO_ERR_INT
  * FIFO ERROR interrupt is generated when TX/RX FIFO overflows or underflows

.. only:: html

   .. include:: i2c_register.rst

.. raw:: latex

   \input{../../en/content/i2c}