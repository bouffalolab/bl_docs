==========
I2C
==========

I2C introduction
=============
I2C (Inter-Intergrated Circuit) is a serial communication bus that uses a multi-master-slave architecture to connect low-speed peripheral devices.

Each device has a unique address identification and can be used as a transmitter or receiver. Each device connected to the bus can set the address by software with a unique address and the always-receiving master-slave relationship. The host can be used as a host transmitter or a host receiver.

If two or more hosts are initialized at the same time, data transmission can prevent data from being destroyed through collision detection and arbitration.

BL702 includes an I2C controller host, which can be flexibly configured with slaveAddr, subAddr, and data transmission to facilitate communication with slave devices. It provides 2 word depth fifo and provides interrupt functions. It can be used with DMA to improve efficiency and flexibly adjust clock frequency.

I2C main features
===================
- Support host mode
- Support multi-master mode and arbitration function
- Flexible clock frequency adjustment

I2C function description
=========================

.. table:: Pin lists
    :widths: 30, 30, 40
    :width: 80%
    :align: center

    +----------+--------------+---------------------------+
    |   Name   |   Type       |    Description            |
    +==========+==============+===========================+
    | I2Cx_SCL | input/output | I2C serial clock signal   |
    +----------+--------------+---------------------------+
    | I2Cx_SDA | input/output | I2C serial data signal    |
    +----------+--------------+---------------------------+

Start and stop conditions
-----------------------------
All transfers begin with a START condition and end with a STOP condition.

The start and stop conditions are generally generated by the master. The bus is considered to be in a busy state after the start condition, and is considered to be in an idle state for a period of time after the stop condition.

Start condition: SDA generates a high-to-low level transition when SCL is high;

Stop condition: SDA generates a low-to-high level transition when SCL is high.

The waveform diagram is as follows:

.. figure:: ../../picture/I2CStopStart.svg
   :align: center

   I2C stop/start condition

Data transmission format
---------------------------
The first 8 bits transmitted are the address byte, including the 7-bit slave address and the 1-bit direction bit. Data sent or received by the host is controlled by the eighth bit of the first byte sent by the host.

If it is 0, it means that the data is sent by the master; if it is 1, it means that the data is received by the master, and then the slave sends an acknowledge bit (ACK). After the data transmission is completed, the master sends a stop signal. The waveform is as follows:

.. figure:: ../../picture/I2CMasterTxRx.svg
   :align: center

   I2C data transmission format

**Timing of master transmission and slave reception**

.. figure:: ../../picture/I2CMasterTxSlaveRx.svg
   :align: center

   Master tx and slave rx

**Timing of master receive and slave send**

.. figure:: ../../picture/I2CMasterRxSlaveTx.svg
   :align: center

   Master rx and slave tx

Arbitration
---------------
When there are multiple masters on the I2C bus, multiple masters may start transmitting at the same time. At this time, it is necessary to rely on the arbitration mechanism to determine which master has the right to complete the next data transfer. The remaining masters must give up control of the bus. The transmission cannot be started again until the bus is free.

During the transmission process, all hosts need to check whether SDA is consistent with the data they want to send when SCL is high. When the SDA level is different from expected, it means that other hosts are also transmitting at the same time. Hosts with different SDA levels will lose the arbitration and other hosts will complete the data transmission.

The waveform diagram of two hosts transmitting data and starting the arbitration mechanism at the same time is as follows:

.. figure:: ../../picture/I2CTxRxTogether.svg
   :align: center

   Tx and Rx together

I2C clock setting
===================

The I2C clock is derived from bclk (bus clock), which can be divided based on the bclk clock.

Register i2c_prd_data can divide the clock of the data segment. The i2c module divides the data transmission into 4 phases. Each phase is controlled by a single byte in the register. The number of samples in each phase can be set. The 4 samples together determine the frequency division coefficient of the i2c clock. 

For example, bclk is 32M and the value of register i2c_prd_data is 0x0f0f0f0f by default without configuration. Then the clock frequency of I2C is 32M / ((15 + 1) * 4) = 500K.

Similarly, the registers i2c_prd_start and i2c_prd_stop also divide the clock of the start bit and stop bit respectively.

I2C configuration process
============================

Configuration item
-----------------------

 - Read and write flags
 - Slave address
 - Slave device address
 - Slave device address length
 - Data (when sending, configure the data to be sent; when receiving, store the received data)
 - Data length
 - Enable signal

Read and write flags
-------------------------

I2C supports two working states: sending and receiving. Register cr_i2c_pkt_dir indicates the sending or receiving status. When it is set to 0, it indicates the sending state, and when it is set to 1, it indicates the receiving state.

Slave address
----------------

Each slave device connected to I2C will have a unique address. Usually the address length is 7 bits. The slave device address will be written into the register cr_i2c_slv_addr. I2C will automatically shift left by 1 bit before sending it from the device address. Transmit/receive direction bit on the low-order complement.

Slave register address
-------------------------

Slave device register address indicates the register address that I2C needs to read and write to a certain register of the slave device. The slave device address will be written to the register i2c_sub_addr, and the register cr_i2c_sub_addr_en needs to be set.

If the register cr_i2c_sub_addr_en is set to 0, the I2C master will skip the slave register address segment when transmitting.

Slave device address length
----------------------------

The slave device address length is decremented by one and written to the register cr_i2c_sub_addr_bc.

Data
--------

The data part represents the data that needs to be sent to the slave device, or the data that needs to be received from the slave device.

When I2C sends data, the data needs to be written into the I2C FIFO in word units in turn, and the data is written to the register address i2c_fifo_wdata of the FIFO.

When the I2C receives data, it needs to read the data from the I2C FIFO in units of words in order, and the received data reads the register address i2c_fifo_rdata of the FIFO.

Data length
---------------

Decrement the data length by one and write to the register cr_i2c_pkt_len.

Enable signal
---------------

After the above configurations are completed, write the enable signal register cr_i2c_m_en to 1 to automatically start the I2C transmission process.

When the read-write flag is set to 0, I2C sends data, and the host sends the process:

1. Start bit

2. (1 bit left from device address + 0) + ACK

3. Slave device address + ACK

4. 1 byte data + ACK

5. 1 byte data + ACK

6. Stop bit

When the read / write flag is set to 1, I2C receives data and the host sends the process:

1. Start bit

2. (1 bit left from device address + 0) + ACK

3. Slave device address + ACK

4. Start bit

5. (1 bit left from device address + 1) + ACK

6. 1 byte data + ACK

7. 1 byte data + ACK

8. Stop bit

FIFO management
==================

I2C FIFO has a 2-word depth, and I2C includes RX FIFO and TX FIFO.
The rx_fifo_cnt in the register i2c_fifo_config_1 represents how much data (in word) in RX FIFO needs to be read.
The tx_fifo_cnt in the register i2c_fifo_config_1 represents how much free space (in word) in TX FIFO for writing.

I2C FIFO status:

- RX FIFO underflow: When the data in RX FIFO is completely read out or empty, if I2C continues to read data from RX FIFO, the rx_fifo_underflow in the register i2c_fifo_config_0 will be set to 1;

- RX FIFO overflow: When I2C receives data until the two words of RX FIFO are filled, without reading RX FIFO, if I2C receives data again, the rx_fifo_overflow in the register i2c_fifo_config_0 will be set to 1;

- TX FIFO underflow: When the data size filled into TX FIFO does not meet the configured I2C data length: cr_i2c_pkt_len in i2c_config, and no new data is filled into TX FIFO, the tx_fifo_underflow in the register i2c_fifo_config_0 will be set to 1;

- TX FIFO overflow: After the two words of TX FIFO are filled, before the data in TX FIFO is sent out, if data is filled into TX FIFO again, the tx_fifo_overflow in the register i2c_fifo_config_0 will be set to 1.

Using DMA
============

I2C can send and receive data through DMA. Setting i2c_dma_tx_en in the register i2c_fifo_config_0 to 1 will enable the DMA TX mode. After the channel for I2C is allocated, DMA will transfer data from memory to the i2c_fifo_wdata register.
Setting i2c_dma_rx_en in the register i2c_fifo_config_0 to 1 will enable the DMA RX mode. After the channel for I2C is allocated, DMA will transfer the data in the register i2c_fifo_rdata to memory.
When I2C is used with DMA, DMA will automatically transfer data, so it is unnecessary for CPU to write data into I2C TX FIFO or read data from I2C RX FIFO.

DMA transmission process
----------------------------

1. Configure the read and write flag i2c_config[cr_i2c_pkt_dir] to 0

2. Configure the slave device address i2c_config[cr_i2c_slv_addr]

3. Configure the slave device register address i2c_sub_addr, the slave device register address length i2c_config[cr_i2c_sub_addr_bc], and configure the slave device register address enable bit i2c_config[cr_i2c_sub_addr_en] to 1

4. Set the length of the sent data i2c_config[cr_i2c_pkt_len]

5. Enable DMA mode transmission, set i2c_fifo_config_0[i2c_dma_tx_en] to 1

6. Configure the data length of DMA transmission DMA_CxControl[TransferSize] (x=0~7)

7. Configure DMA source address DMA_CxSrcAddr, data width DMA_CxControl[SWidth], burst size DMA_CxControl[SBSize], set DMA_CxControl[SI] to 1 to enable automatic address accumulation mode

8. Configure the DMA destination address DMA_CxDstAddr to i2c_fifo_wdata, data width DMA_CxControl[DWidth] to 32 and burst size DMA_CxControl[DBSize], clear DMA_CxControl[DI] to disable the address automatic accumulation mode

9. Enable DMA

10. Configure i2c_config[cr_i2c_m_en] to 1 to enable I2C 

DMA receiving process
--------------------------

1. Configure the read-write flag i2c_config[cr_i2c_pkt_dir] to 1

2. Configure the slave device address i2c_config[cr_i2c_slv_addr]

3. Configure slave device register address i2c_sub_addr, slave device register address length i2c_config[cr_i2c_sub_addr_bc], configure slave device register address enable bit i2c_config[cr_i2c_sub_addr_en] to 1

4. Set the length of the received data i2c_config[cr_i2c_pkt_len]

5. Enable DMA mode reception, set i2c_fifo_config_0[i2c_dma_rx_en] to 1

7. Configure the data length of DMA transmission DMA_CxControl[TS] (x=0~7)

8. Configure DMA source address DMA_CxSrcAddr to i2c_fifo_rdata, data width DMA_CxControl[SWidth] to 32 and burst size DMA_CxControl[SBSize], clear DMA_CxControl[SI] to disable address automatic accumulation mode

7. Configure DMA destination address DMA_CxDstAddr, data width DMA_CxControl[DWidth], burst size DMA_CxControl[DBSize], set DMA_CxControl[DI] to 1 to enable automatic address accumulation mode

9. Enable DMA

10. Configure i2c_config[cr_i2c_m_en] to 1 to enable I2C 

I2C interrupt
==============

I2C includes the following interrupts:

 - I2C_TRANS_END_INT: I2C transfer end interrupt
 - I2C_TX_FIFO_READY_INT: Interrupt is triggered when I2C TX FIFO has free space available for filling
 - I2C_RX_FIFO_READY_INT: When I2C RX FIFO receives data, trigger interrupt
 - I2C_NACK_RECV_INT: When the I2C module detects a NACK state, an interrupt is triggered
 - I2C_ARB_LOST_INT: I2C arbitration lost interrupt
 - I2C_FIFO_ERR_INT: I2C FIFO ERROR interrupt

.. only:: html

   .. include:: i2c_register.rst

.. raw:: latex

   \input{../../en/content/i2c}